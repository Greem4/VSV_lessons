# Понятие Batch. Использование в JDBC

Сегодня мы поговорим об оптимизации выполнения большого числа подряд идущих запросов с помощью batch-операций. Также
эти операции иногда называют групповыми или пакетными.

## Актуальность

При решении прикладных задач иногда возникают ситуации, в которых требуется выполнить большое число запросов подряд -
как правило, вставка или обновление множества строк в таблице.

На первый взгляд тут есть два варианта решения:

1. Попытаться это реализовать одним запросом. Для INSERT-операций этой реализуемо на некоторых СУБД - в т.ч. на
   PostgreSQL. Но если число вставляемых строк не фиксировано - придется извернуться с установкой параметров запроса,
   что не очень удобно. В случае с обновлением - не придется изобретать велосипед, если все нужные строки должны
   быть изменены однотипно. А если каждая запись должна обновиться по собственным правилам - реализовать это в один
   запрос практически невозможно. По крайней мере, оставив код понятным и поддерживаемым;
2. Выполнить по отдельному запросу на вставку/обновление для каждой строки. Технических ограничений для этого нет,
   реализовать такой подход намного проще, чем первый сценарий.

Собственно, второй вариант выглядит логичным и надежным, если бы не одно "но": в базовом виде каждый запрос - это
действительно запрос от Java-приложения к СУБД. А значит каждый запрос будет нести издержки на коммуникацию между
Java-приложением и СУБД, увеличивая итоговое время выполнения подобного метода. В данной статье мы не будем
углубляться в природу таких издержек - боюсь, на данном уровне знаний будет недостаточно, чтобы разобрать эту тему.
Но сам факт их наличия кажется интуитивно-понятным.

Наиболее очевидный способ описываемые издержи сократить - отправить несколько запросов одним "пакетом". Т.е. за один
раз передать СУБД несколько запросов, которые она должна выполнить. Именно передача такого пакета и называется
batch-операцией.

## API

Для реализации описанной концепции существует несколько методов в `Statement` и `PreparedStatement`. Постараемся
разобраться с назначением каждого.

### Statement#addBatch(String sql)

Данный метод позволяет добавлять запрос в батч. Его плюс в том, что он позволяет объединять в батче разные запросы -
скажем, и вставку, и обновление данных. Минус тот же, что и у `Statement` в целом - он не поддерживает
параметризации, т.е. предназначен, в первую очередь, для статических запросов. А они практически никогда не
нуждаются в пакетной обработке как таковой. Но об этом мы подробнее поговорим в отдельном пункте.

Синтаксис применения прост:

```java
try (Connection connection = getConnection();
     Statement statement = connection.createStatement()) {

    statement.addBatch("insert into passenger (first_name, last_name, birth_date) values ('Name0', 'Surname0', '1997-12-20')");
    statement.addBatch("insert into passenger (first_name, last_name, birth_date) values ('Name1', 'Surname1', '1997-12-20')");
    statement.addBatch("insert into passenger (first_name, last_name, birth_date) values ('Name2', 'Surname2', '1997-12-20')");
    statement.addBatch("update passenger set first_name = 'IVAN' where id = 1");

//   ... - Выполнение батча
} catch (SQLException e) {
    log.error(e);
}
```

Также стоит отметить, что при попытке вызвать этот метод для `PreparedStatement` будет выброшено исключение.

### Statement#clearBatch()

Метод, позволяющий удалить из батча все запросы, которые были ранее добавлены через `addBatch()`.

В целом, факт наличия такого метода логичен - вполне вероятно, что кому-нибудь когда-нибудь он может понадобиться.
Но пример его применения при адекватном подходе к работе с батчем придумать сложно.

Можно было бы предположить, что он полезен в ситуациях, когда один `Statement` последовательно работает с
несколькими батчами, но обычно список запросов для батча автоматически очищается при его отправке в СУБД. Впрочем,
нельзя исключать, что есть JDBC-драйверы, которые этого не делают - при работе с ними будет разумно использовать
`clearBatch()`.

### Statement#executeBatch()

Вероятно, самый интересный метод при работе с батчами - именно он отправляет собранные запросы в СУБД, он же занимается
обработкой результатов применения батча.

Пример использования:

```java
try (Connection connection = getConnection();
     Statement statement = connection.createStatement()) {

    statement.addBatch("insert into passenger (first_name, last_name, birth_date) values ('Name0', 'Surname0', '1997-12-20')");
    statement.addBatch("insert into passenger (first_name, last_name, birth_date) values ('Name1', 'Surname1', '1997-12-20')");
    statement.addBatch("insert into passenger (first_name, last_name, birth_date) values ('Name2', 'Surname2', '1997-12-20')");
    statement.addBatch("update passenger set first_name = 'IVAN' where id = 1");

    statement.executeBatch();
} catch (SQLException e) {
    log.error(e);
}
```

В базовом варианте использования не слишком нужно возвращаемое значение `executeBatch()`. Тем не менее оно может
быть полезно в целях мониторинга - этот метод возвращает `int[]`, где каждая ячейка массива - некий результат
выполнения соответствующего запроса из батча:

- Значения от 0 и выше - число строк, измененных запросом;
- -2 - запрос выполнен успешно, но нет информации о числе измененных строк. Особенности применения этого значения
  могут зависеть от драйвера;
- -3 - при выполнении одного из запросов произошла ошибка. Как правило, в таком случае метод завершится с
  исключением, но это значение все еще может нам встретиться. Об этом ниже.

Метод может завершить работу с `BatchUpdateException`. Обычно это означает, что при выполнении одного из запросов
произошла ошибка. Особенность данного исключения в том, что оно содержит поле `updateCounts`, которое содержит
массив целых чисел, сформированный по тем же правилам, что описаны выше. И именно в нем может быть встречено
значение -3.

Способы обработки батча при возникновении ошибки в одном из запросов зависят от СУБД и особенностей конфигурации.
Поэтому этот нюанс лучше уточнять для каждой новой СУБД, с которой вы планируете работать. В случае с PostgreSQL в
базовом сценарии - обработка батча будет прекращена и результат выполнения предыдущих запросов будет отменен. Что, в
целом, является наиболее прозрачным из возможных вариантов.

> **!NB**: Достаточно распространено убеждение, что батч-операции гарантируют транзакционность выполнения запросов.
> Закреплению этого мнения помогает и то, что для отдельных СУБД это соответствует действительности. Но само API не
> гарантирует такого поведения и на практике возможны различные сценарии, вплоть до пропуска запроса с ошибкой и
> выполнения следующих запросов в батче.
>
> Рекомендую уточнять поведение конкретного драйвера перед использованием.

### PreparedStatement#addBatch()

Кроме методов `Statement`, также существует и метод добавления в батч для `PreparedStatement`. В целом, на
особенностях применения батчей для `PreparedStatement` стоит остановиться отдельно.

Как мы помним из предыдущей статьи, `PreparedStatement` предназначен для работы с единственным шаблоном запроса. Это
распространяется и на работу с батчами, что не позволяет использовать в одном батче разные типы запросов или запросы
к разным таблицам (что, в принципе, возможно при работе через `Statement`).

Метод `addBatch()` в такой конъюнктуре нужен не для добавления в батч новых запросов, а для насыщения темплейта
параметрами. Таким образом применение данного метода выглядит примерно так:

```java
private void addPassengers(Collection<Passenger> passengers) {
    var sql = "insert into passenger (first_name, last_name, birth_date) values (?, ?, ?)";

    try (Connection connection = getConnection();
         PreparedStatement statement = connection.prepareStatement(sql)) {

        for (Passenger passenger : passengers) {
            statement.setString(1, passenger.getFirstName());
            statement.setString(2, passenger.getLastName());

            Date birthDate = Date.valueOf(passenger.getBirthDate());
            statement.setDate(3, birthDate);

            statement.addBatch();
        }

        statement.executeBatch();
    } catch(SQLException e) {
        log.error(e);
    }
}
```

Получается, что после вызова `addBatch()` ранее указанные параметры фиксируются для одного запроса, а сразу после
можно указывать параметры уже для следующего запроса в том же батче. При этом не требуется делать смещение для
индексов запроса - ведь это новый запрос в рамках батча.

## Практика применения

Ранее уже было сказано, что обычно batch-операции применяются для вставки и обновления. В случае с обновлением стоит
отметить, что наиболее часто применяется обновление с фильтрацией по primary key - т.е. каждый запрос будет
обновлять единственную запись. Это достаточно распространенный сценарий.

В отличие от него, ситуации, когда `UPDATE` вызывается по иному критерию фильтрации и обновляет одним запросом
несколько записей - относительно редкий, хоть и вполне встречается на практике. Но обычно такие запросы не требуют
выполнения в батче.

Кроме того, постараемся разобраться, почему батчи не популярны для других видов операций.

### SELECT и запросы с RETURNING

Здесь все очевидно: эти запросы возвращают `ResultSet`. При этом стандартное API для батчей подобных объектов не
возвращает. Если учесть, что получение `ResultSet` из нового запроса закрывает `ResultSet` из предыдущего -
выполнение таких операций в батче теряет смысл в принципе.

### DDL

Здесь логика несколько сложнее. Батч-операции необходимы для увеличения производительности при работе с БД. Но
DDL-запросы редко (почти никогда) применяются тогда, когда приложение находится в рабочем состоянии. Обычно они
запускаются на старте программы, подготавливая БД для работы с приложением. Таким образом, они работают тогда, когда
оптимизации времени выполнения не так критичны.

Кроме того, обычно такие запросы запускаются через отдельный инструмент "миграций" - специальную технологию,
направленную на поддержание схемы БД в актуальном состоянии. Мы познакомимся с одним из таких инструментов в следующем
разделе. Несмотря на то, что эти инструменты могут запускаться самим Java-приложением и также работают с СУБД через
JDBC - они достаточно жестко инкапсулированы и отделены от взаимодействия с БД, которое происходит в рамках нормальной
работы программы.

### DCL

Напомню: DCL - раздел SQL, предоставляющий функциональность для разграничения прав пользователей и ролей на уровне СУБД.

Здесь тоже просто: обычно DCL вообще не применяется из Java-приложения - настройка доступов производится отдельно. 
Это связано с требованиями безопасности. Кроме того, чаще всего подобная настройка лежит не на Java-разработчиках.

DCL в Java-коде почти всегда будет маркером некомпетентности специалиста.

### TCL

TCL - раздел SQL, предназначенный для управления транзакциями.

JDBC имеет отдельный API для работы с транзакциями - мы с ним познакомимся в следующем уроке. Кроме того, сложно 
представить даже теоретический сценарий, когда требуется применять операторы вроде `COMMIT` и `ROLLBACK` внутри батча.

На этом мы завершаем знакомство с пакетными операциями.

#### С теорией на сегодня все!

![img.png](../../../commonmedia/defaultFooter.jpg)

Переходим к практике:

## Задача

На базе [репозитория](https://github.com/KFalcon2022/jdbc-practical-tasks) реализуйте следующую функциональность:

- Добавьте метод для добавления множества пассажиров в таблицу;
- Добавьте метод для обновления множества пассажиров в таблице;
- Покройте новые методы юнит-тестами.

Ветка для PR: `for-pr`.

> Если что-то непонятно или не получается – welcome в комменты к посту или в лс:)
>
> Канал: https://t.me/ViamSupervadetVadens
>
> Мой тг: https://t.me/ironicMotherfucker
>
> **Дорогу осилит идущий!**
