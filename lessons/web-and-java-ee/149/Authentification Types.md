# Виды аутентификации

Ранее уже неоднократно затрагивалась тема авторизации и аутентификации в приложениях. И в одной из ближайших статей 
мы разберемся, как реализовать аутентификацию на базе сессий в сервлетном приложении - в дальнейшем эта тема получит 
развитие уже базируясь на механизмах Spring.

А сегодня постараемся погрузиться глубже в саму тему аутентификации и разобраться с тем, какие виды аутентификации 
существуют.

## Введение

Как уже говорилось ранее, аутентификация - это процесс проверки личности в работе с информационной системой. 
По своей сути аутентификация сводится к сопоставлению данных, переданных пользователем для 
аутентификации с теми, которые уже хранятся в системе - это справедливо как для логина и пароля, так и 
для любых иных учетных данных. Соответственно, способы аутентификации так или иначе варьируются именно по виду 
учетных данных или по способу их передачи на сервер.

В ходе развития ИТ было придумано множество способов аутентификации, которые удобны для различных ситуаций. Со 
временем добавляются и новые - в основном, в разрезе биометрических данных. К последним можно отнести всевозможные 
отпечатки пальцев, Face ID (считывание лица камерой) и т.д. Также способы аутентификации могут эволюционировать в 
силу того, что в существующих находят уязвимости или они становятся недостаточны для реализации иной 
функциональности - примеры последнего будут ниже.

Текущая статья посвящена наиболее классическим способам, без углубления в узкую специфику. Нет особого смысла в том, 
чтобы перечислять все возможные варианты аутентификации, актуальные на сегодняшний момент - достаточно описать ключевые 
тенденции.

## Аутентификацию по паролю

Наиболее распространенный способ аутентификации, знакомый каждому. Фактически, обобщает несколько технически 
различных способов на основании передаваемых учетных данных. 

В веб-приложениях общая схема заключается в передаче логина и пароля на сервер через специально выделенный для этого 
запрос. На сервере происходит валидация логина - почты, юзернейма, номера телефона - не суть важно. Есть 
пользователь с таким логином существует - извлекается его пароль* и сравнивается с тем, который был передан в 
запросе. Если пароль совпадает - процесс аутентификации произошел успешно.

> *Как правило, пароль пользователя не хранится в изначальном виде - это серьезная уязвимость в случае, если база 
> данных попадет к злоумышленникам. Вместо этого хранится хеш пароля - некая строка фиксированной длины, получаемая 
> посредством хеширования определенным алгоритмом. В детали углубляться не будем - это область криптографии. Но 
> о наиболее известных алгоритмах хеширования вы могли слышать - MD5, SHA-256. Также распространена практика
> использования "соли" - некой дополнительной строки, которая добавляется к паролю и лишь затем на базе нее вычисляется
> хеш. При желании, в тему хранения авторизационных данных можно углубиться самостоятельно, в пределах курса эта 
> тема кажется избыточной.
> 
> Возвращаясь к сравнению паролей при аутентификации, получается, для валидации пароля необходимо вычислить его хеш и 
> сравнить данный хеш с тем, который хранится в базе данных. Если хеши совпадают - пароль валиден.
> 
> Несложно догадаться, что как и в случае с `Object#hashcode()` возможна коллизия - это бич любой хеш-функции. Но 
> фактически его вероятность стремится к нулю, особенно при ограничении пароля по максимальной длине - скорее всего
> размер хеша окажется больше, чем размер оригинального пароля.

## Basic Authentication

Частный случай аутентификации по паролю.

Заключается в использовании заголовка запроса `Authorization`, в котором при каждом запросе передается логин и пароль 
пользователя, закодированный в [Base64](https://ru.wikipedia.org/wiki/Base64). Выглядит это примерно так:

```
Authorization: Basic YWRtaW46YWRtaW4=
```

Здесь `Authorization` - заголовок, `Basic YWRtaW46YWRtaW4=` - значение заголовка. `Basic` обозначает способ 
аутентификации - заголовок используется различными механизмами аутентификации, что делает актуальным указание на 
механизм, используемый именно в данном случае. `YWRtaW46YWRtaW4=` - логин и пароль, разделенные символом `:`, 
закодированные в Base64. В данном случае - `admin:admin`.

Алгоритм примитивен до невозможности, но несет за собой ряд последствий, которые могут быть не очевидны на первый 
взгляд:

1. Не нужен отдельный запрос для логина - все равно любой запрос необходимо передавать логин и пароль. Наверное, 
   единственное, что можно условно отнести к плюсам данного подхода;  
2. Хранение учетных данных браузером. Тот факт, что в каждом запросе необходимо отправлять логин и пароль, означает 
   то, что браузер должен их хранить. Каким образом - вопрос вторичный, но сам факт хранения учетных данных на 
   клиенте делает Basic Auth уязвимым подходом, ведь если злоумышленник получит доступ к устройству - он получит и 
   доступ к авторизационным данным. Кодировка в Base64 здесь не является какой-либо степенью защиты - этот формат 
   легко дешифруем даже в ручном режиме; 
3. Безопасность передачи по сети. Достаточно перехватить любой запрос на сервер - и злоумышленник получит данные 
   авторизации, ведь они передаются практически в открытом виде. Этот пункт стал практически неактуален с массовым 
   переходом на HTTPS - этот протокол шифрует, в том числе, заголовки запроса. Но HTTPS получил популярность гораздо 
   позже, чем появился Basic Auth. А при использовании HTTP он крайне уязвим;   
4. Логаут. По сути, при данном подходе невозможно реализовать функциональность "выхода" из учетной записи на стороне 
   сервера. Т.е. пользователя можно заблокировать, ему можно сменить пароль, но именно "логаут" связан исключительно 
   со сроком хранения авторизационных данных браузером. Фактически это является еще одной уязвимостью в сравнении с 
   более продуманными механизмами. Но об этом чуть позже. 

В современных системах данный подход фактически не используется. Но остается актуальным как некая дополнительная 
степень защиты в ряде случаев. В основном, для закрытия базового доступа к не слишком чувствительной информации - 
например, если доступ к сайту надо ограничить случайным лицам вплоть до того, чтобы не отображать даже страницу 
логина. Или для ограничения доступа к документации API какой-то системы, которая не является чувствительной 
информацией сама по себе, но будучи в открытом доступе может облегчить работу злоумышленникам. 

## Session-Based Authentication

Проблема любой аутентификации в приложениях, работающих на базе HTTP - stateless. Т.е. в любом запросе, кроме
непосредственного запроса на логин необходимо каким-то образом указывать, что ранее аутентификация прошла успешно. В 
случае с HTTP это выражается в передаче с запросом какой-то информации.

Данную информацию тоже можно видом авторизационных данных, с помощью которых будет производиться аутентификация 
запроса - ведь мы будем сопоставлять эти данные с имеющейся в системе информацией, чтобы определить личность 
пользователя. Нюанс в том, что сам факт наличия таких данных (или информация в них содержащаяся) может определять 
доступность конкретного ресурса для пользователя, что переносит нас в область ответственности авторизации. Во многом 
из-за этого и происходит путаница с процессами аутентификации и авторизации, при чем не только среди новичков.

Основная тема данного пункта как раз и посвящена одному из наиболее распространенных способов провести 
аутентификацию отдельных запросов, выполняющихся после логина.

Общий принцип аутентификации по сессии уже был описан в более ранних статьях, но тезисно проговорим его еще раз:

1. Через специальный запрос на логин происходит аутентификация пользователя;
2. При успешной аутентификации в ответе на логин передается информация о Cookie с идентификатором сессии. В принципе,
   не обязательно использовать именно Cookies, но это классическая реализация. Для Java-приложений такой Cookie 
   обычно является `JSESSIONID`;
3. Каждый следующий запрос к системе передает Cookie с идентификатором сессии;
4. При обработке запроса проверяется наличие сессии по указанному идентификатору на сервере - по сути, происходит 
   аутентификация, только валидация происходит не по логину и паролю, а по идентификатору сессии. При этом в 
   атрибутах самой сессии может храниться любая информация, в т.ч. идентификатор пользователя, его роль или другая 
   информация, необходимая для определения прав юзера при обработке запроса - т.е. информация, на базе которой будет 
   производиться авторизация.

Данный подход безопаснее, чем Basic Auth, ведь у нас нет необходимости хранить логин и пароль на стороне клиента - 
лишь id сессии. Кроме того, у нас остается пространство для маневра в случае логаута - мы можем удалить сессию на 
сервере, что сделает невозможным логин по ней, даже если идентификатор все еще будет храниться на клиенте. Это 
полезно как в случае опасений, что идентификатор сессии попал в руки злоумышленников, так и для штатного ограничения 
длительности сессии. В зависимости от требований к системе мы можем ограничивать время жизни сессии как от логина, 
так и от последнего действия пользователя.

При этом ряд рисков, характерных для Basic Auth все еще остаются:

1. Id сессии хранится на клиенте, т.е. если злоумышленник получит к нему доступ - он сможет с этим id сессии 
   получить доступ к системе, в том числе с другого компьютера. Для минимизации этого риска существуют определенные 
   инструменты - от короткого времени жизни самой сессии до валидации запроса по метаинформации, позволяющей 
   идентифицировать конкретное устройство - IP, используемый User-Agent (читай, браузер), разрешение экрана и прочая 
   второстепенная информация;
2. Использование HTTP вместо HTTPS. Опять же, HTTP в базовом виде не обеспечивает безопасность передаваемой 
   информации, что позволяет перехватить id сессии в запросе. Методы борьбы - те же, что и в предыдущем пункте.

Дополнительным бонусом, в сравнении с Basic Auth можно также считать возможность управления сессиями - т.е. мы можем 
определять, допустимо ли параллельное пользование системой одним юзером с нескольких устройств одновременно. Для 
этого достаточно обеспечить привязку сессий к пользователям. Также это позволяет сохранять в информацию о сессии 
метаинформацию, описанную выше, что делает возможным валидацию по ней. 

## Token-Based Authentication

Достаточно обширный набор подходов к аутентификации, обобщенный по принципу использования "токенов". Токен - 
определенный набор зашифрованной текстовой информации.

Ключевая особенность токенов заключается именно в том, что они несут полезную нагрузку. Если при аутентификации по 
сессии мы оперируем лишь идентификатором, а вся важная информация - связь сессии с юзером, срок жизни сессии и т.д. 
хранится в атрибутах сессии на сервере, то токен является (или может являться) самодостаточным - в нем может 
храниться вся вышеобозначенная информация. Но для того, чтобы извлечь ее из токена - необходим ключ шифрования, без 
которого токен является лишь набором символов.

Такой подход полезен для различных сценариев. Попробуем рассмотреть наиболее популярные:

1. Один клиент скрывает под собой работу с несколькими серверными приложениями, которые не имеют общего хранилища. 
   Причины такой организации архитектуры приложения мы пока не будем затрагивать - это отдельный большой раздел. 
   Важно то, что в таких случаях некоторые из серверов могут вообще не иметь никакой информации о существующих 
   пользователях. Все, что им будет доступно - информация, скрытая в токене;
2. Существует ряд приложений, для которых мне необходима сквозная авторизация. Это особенно актуально во 
   внутренних корпоративных приложениях, когда заводится одна учетная запись, по которой доступны различные сервисы. 
   Скажем, Jira, Confluence и GitLab - набор, знакомый большинству разработчиков. Почему бы не сделать так, чтобы 
   логин в одном приложении избавлял от необходимости логина в других*?  
3. За аутентификацию отвечает не то приложение, для которого предназначен токен. В данном случае речь про выделенные 
   сервис аутентификации - он может быть публичным (Google, Facebook и другие) или же приватным внутри корпоративной 
   экосистемы. Чуть более подробно эту тему затронем в пункте, посвященном OAuth 2.0. Токены в данном случае хороши 
   тем, что они позволяют сохранить в себе информацию о том, кто выдал токен, кому и какой срок действия у данного 
   токена. В подобных ситуациях иногда токен - единственное, что вообще получает целевой сервер от сервиса 
   аутентификации. Т.е. в токене необходимо получить минимально достаточный набор информации о пользователе.

Описанные выше пункты могут комбинироваться в пределах одной системы. Или экосистемы, если в ней присутствует 
несколько независимых друг от друга систем. 

> *Именно для сквозной авторизации не обязательно использовать именно аутентификацию на базе токенов. Но это 
> распространенный подход, к тому же, решающий часть типовых проблем. В целом, SSO (Single Sign-On) - обширная и 
> интересная тема. Но погружаться в нее тяжело, особенно без наличия опыта реальной разработки. 

Токены бывают различны по своей внутренней структуре. Кроме того, любой популярный формат токена определяет набор 
зарезервированных атрибутов, позволяет определить собственные атрибуты, которые будут доступны из токена, а также 
содержит некий механизм "подписи", позволяющий определить, что токен не был изменен после выдачи.

Тот факт, что в токене содержится информация о пользователе и срок действия самого токена, делает токены настолько 
самодостаточными в плане аутентификации, что конечные сервисы даже не имеют необходимости хранить сами токены - 
достаточно лишь обеспечить механизм их валидации после расшифровки содержимого.

Безопасность подхода гарантируется либо безопасно переданным ключом
[симметричного шифрования](https://ru.wikipedia.org/wiki/%D0%A1%D0%B8%D0%BC%D0%BC%D0%B5%D1%82%D1%80%D0%B8%D1%87%D0%BD%D1%8B%D0%B5_%D0%BA%D1%80%D0%B8%D0%BF%D1%82%D0%BE%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D1%8B),
либо механизмами 
[ассиметричного шифрования](https://ru.wikipedia.org/wiki/%D0%9A%D1%80%D0%B8%D0%BF%D1%82%D0%BE%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%B0_%D1%81_%D0%BE%D1%82%D0%BA%D1%80%D1%8B%D1%82%D1%8B%D0%BC_%D0%BA%D0%BB%D1%8E%D1%87%D0%BE%D0%BC).
Применение того или иного подхода зависит от используемого типа токена и конкретной системы - не все токены 
регламентируют механизм шифрования.

Тема аутентификации на базе токенов объемна, особенно если пытаться рассказать о ней в общем виде, не сужаясь до 
конкретной имплементации. В силу этого многие вещи имеет смысл отдавать на самостоятельное изучение. Так, наиболее 
популярным форматом токенов является **JWT** (JSON Web Token). Подробнее можно узнать здесь:
[RFC 7519](https://datatracker.ietf.org/doc/html/rfc7519). Либо по запросу в гугл "JWT" в более простом формате. 

### Сценарий аутентификации с помощью токена

В наиболее простом виде Token-Based аутентификация выглядит так:

0. На этапе интеграции всем системам, которые должны работать с токеном предоставляется ключ шифрования, позволяющий 
   расшифровать токен. Механизм передачи самого ключа не имеет значения - он определяется в каждом отдельно взятом 
   случае, вплоть до пересылки в рабочем мессенджере (так делать не надо), обычно такой ключ имеет большой срок жизни 
   или не имеет такого ограничения вовсе. В данном пункте описан шаг, которые должны сделать разработчики системы, 
   чтобы описанное далее было возможным;
1. Происходит логин в системе или сервисе, отвечающем за аутентификацию. Сам логин может опираться на логин-пароль 
   или другой способ, это не критично;
2. В случае, если логин прошел успешно, в ответе клиенту отправляется сообщение в определенном формате, которое 
   содержит определенный набор атрибутов. Например, юзернейм, роль пользователя и время жизни токена. Также в 
   сообщение входит какая-то подпись - например, хеш сообщения без подписи. Сообщение целиком зашифровано определенным 
   алгоритмом - это и есть токен;
3. Клиент обращается к какому-нибудь серверу - тому же, который отвечал за аутентификацию или иному - это не имеет 
   значения, если сервер поддерживает аутентификацию с помощью данного токена. В запросе передается токен. Передачи 
   токена зачастую используется знакомый нам заголовок `Authorization` с указанием способа аутентификации `Bearer`, 
   но это не обязательное требование;
4. Целевой сервер получает запрос, пытается расшифровать токен с помощью ключа, полученного на этапе 0. Если это 
   удается - проверяет корректность данных: не истек ли токен, валидна ли подпись, возможно - еще какие-то шаги, 
   специфичные именно для этой системы;
5. Если все проверки пройдены успешно, запрос обрабатывается далее;
6. Пункты 3-5 повторяются при каждом новом запросе.

Как несложно заметить, даже в упрощенном и обобщенном виде алгоритм намного сложнее, чем в случае с аутентификацией 
по сессии. При этом риски, в целом, те же, что и в случае с сессиями - токен можно получить, имея доступ к 
компьютеру, можно перехватить, если используется HTTP, а не HTTPS. Соответственно, данный подход актуален в первую 
очередь для систем, состоящих из множества серверов или систем, не имеющих общего хранилища. В более простых случаях 
это может оказаться лишним переусложнением процесса аутентификации.

### Access и Refresh токены

Знакомство с аутентификацией на базе токенов будет неполным, если не раскрыть данный подпункт.

Как было отмечено выше, токены, как правило, содержат в себе срок жизни. Само по себе это означает, что после 
завершения этого срока токен становится недействительным и необходимо снова обратиться к сервису аутентификации. 
Один из способов борьбы со злоумышленниками подразумевает выдачу краткосрочных токенов - таким образом даже 
утерянный токен будет представлять угрозу для системы в течение небольшого промежутка времени - нескольких от 
нескольких минут до часа, в зависимости от ~~степени паранойи~~ требований к безопасности.

Такой короткосрочный токен называется **Access Token**. Использование подхода, описанного выше, имеет очевидный 
недостаток: клиент вынужден логиниться в сервисе аутентификации раз в несколько минут или раз в час. Это, очевидно, 
неудобно.

Чтобы избежать подобного, вводится понятие **Refresh Token**. Это отдельный токен, обычно одноразовый, который 
используется при истечении Access Token'а для его обновления. Т.е. при логине в сервисе аутентификации клиент 
получается пару токенов: Access и Refresh. До тех пор, пока Access Token валиден - используют его. Как только 
наступает срок экспирации (истечения) токена, клиент вновь обращается к сервису аутентификации, но отправляет не 
логин и пароль, а Refresh Token. Если токен валиден - клиент получит новую пару из Access и Refresh токенов.

Как правило, Refresh Token имеет больший срок жизни - например, сутки. При этом он жестко привязан в своей области 
использования - с ним может работать только сервис аутентификации, что дает большее пространство для маневра - 
например, такие токены можно сохранять в хранилище. С одной стороны, это шаг назад - описанные выше сценарии работы 
с токенами не требуют их хранения. С другой стороны, это позволяет "отозвать" - принудительно инвалидировать - токен 
на сервере, если есть подозрение, что токен был скомпрометирован (украден).

По итогу, описанный подход имеет следующие свойства:

1. Усложняет жизнь злоумышленнику. Конечно, данный подход не спасет в ситуации, когда злоумышленник получил доступ к 
   компьютеру, хранящему пару токенов. Но риски перехвата токена при передаче по сети в большой степени нивелируются - 
   перехваченный Access Token короткоживущий, а Refresh Token имеет смысл перехватывать только при получении 
   клиентом новой пары токенов. Вкупе с остальными мерами предосторожности, описанными в статье, этот подход делает 
   систему аутентификации достаточно надежной;
2. На пользователя фактически не оказывает значения время жизни токена - ему не надо явно проходить процедуру логина 
   при истечении токена, поскольку обращение к сервису аутентификации произойдет с помощью Refresh Token'а, обычно 
   незаметно для клиента.

## OAuth 2.0

OAuth 2.0 - один из популярных протоколов, позволяющих приложению делегировать аутентификацию отдельному сервису. 
Если вы используете в каких-то сервисах вход через Google, Facebook или иную соц. сеть - скорее всего вы 
сталкивались с данным протоколом. Google и Facebook в данном случае выступает сервисами аутентификации. Такие 
сервисы есть и для корпоративных клиентов (например, Okta). Возможно и создание собственного сервиса аутентификации. 
Но конкретный сервис - это специфика, которая имеет мало значения на данном этапе.

OAuth 2.0 интересует нас по нескольким причинам:

1. Он позволяет достаточно наглядно показать, как работает аутентификация через выделенный сервис, в том числе не 
   контролируемый командой целевой системы. При этом протокол популярен и по нему можно найти массу информации для 
   новичков, если данная статья покажется неинформативной;
2. Знакомство с протоколом позволит познакомиться с некоторыми базовыми терминами, которые будут актуальны вне 
   зависимости от способа реализации Single Sign-On. А с ним приходится сталкиваться относительно часто в тех или 
   иных вариациях;
3. Наконец, это действительно популярный способ аутентификации и его вполне могут предложить обсудить на 
   собеседовании. Поэтому хотя бы в общем виде стоит ознакомиться с данным протоколом.

На этапе реализации OAuth 2.0 со стороны целевой системы как правило происходит регистрация системы в сервисе 
аутентификации. Это необходимо для того, чтобы сервис аутентификации мог выдать токен адресно, конкретно для 
целевого приложения. Также это позволяет определить доступы, которые будут выданы целевому приложению относительно 
сервиса аутентификации - например, получения ФИО пользователя, его аватара, почты или иных данных. Возможно - 
отправка каких-то уведомлений. Детали зависят от конкретного сервиса аутентификации, но в большой степени это актуально 
для сервисов, ассоциированных с социальными сетями.

Сервис аутентификации также может обозначаться как Authentication Service (логично) или **Identity 
Provider**, он же **IdP**. Это общая терминология. В случае с OAuth 2.0 чаще всего такой сервис может быть обозначен 
как **OAuth Server**.

Целевое приложение - сервер, который будет обрабатывать какие-то бизнес-запросы авторизованного пользователя, обычно 
именуют как **Service Provider**, он же **SP**. Также используется термин **Relying Party** (**RP**). В случае с 
OAuth 2.0 часто (но не всегда) один токен от IdP валиден лишь для одного SP. Кроме этого можно встретить термин
**Resource Server** - он актуален в первую очередь для OAuth 2.0.

Итак, как же выглядит аутентификация с помощью OAuth 2.0:

1. Запрос на авторизацию. С точки зрения UI ассоциировать с нажатием условной кнопки "Войти через Google". Вместе с 
   запросом на авторизацию передаются данные о клиенте (предоставляются IdP на этапе интеграции), запрашиваемые 
   права и адрес, по которому потом должен быть перенаправлен пользователь - обычно адрес клиентского приложения;
2. Пользователь перенаправляется на страницу авторизации данного IdP, где может ввести логин и 
   пароль или иным способом пройти аутентификацию;
3. IdP производит аутентификацию пользователя и запрашивает согласие на предоставление доступа 
   клиенту;
4. IdP получает согласие пользователя, выдает "грант авторизации" и перенаправляет пользователя
   обратно на клиентское приложение. Точнее, на адрес, указанный для редиректа в п.1;
5. Клиентское приложение получает "грант авторизации"*. Что такой грант из себя представляет - зависит от реализации, 
   спецификация протокола предоставляет несколько вариантов. Так или иначе, это некие учетные данные, которые готов 
   принять IdP;
6. Клиент передает IdP грант авторизации и идентификатор и секретный ключ клиента;
7. IdP валидирует грант и данные клиента, в случае успеха возвращает клиенту Access Token и, опционально, Refresh 
   Token, если он предусмотрен в данной реализации;
8. Клиент совершает бизнес-запрос к SP с передачей токена;
9. Если токен может быть проверен SP (например, если используется JWT) - токен валидируется SP, если токен валиден - 
   запрос обрабатывается далее. Если токен не может быть провалидирован SP самостоятельно - SP отправляет 
   дополнительный запрос к IdP для валидации токена. И уже при подтверждении валидности токена от IdP будет 
   происходить дальнейшая обработка запроса. Фактический сценарий зависит от вида токена, предоставляемого 
   конкретным IdP. 

> *Несмотря на то, что здесь не указывается конкретный грант авторизации, фактически данный флоу описывает 
> использование "Authorization Code Grant". Это наиболее распространенный и безопасный способ аутентификации в OAuth 
> 2.0. Грант в таком случае представляет собой одноразовый код, который можно обменять на токен.

Если внимательно просмотреть весь процесс аутентификации выше, может показаться, что существует некий лишний шаг - 
клиент получает грант авторизации, чтобы потом обменять его на токен. Это достаточно тонкий момент, по сути, 
обеспечивающий дополнительную степень защиты в сетевой коммуникации. В силу того, что не всем эта проблематика 
понятна и интересна при первом знакомстве с OAuth 2.0, не буду расписывать обоснование подробно. При желании, его 
можно найти здесь:
[ссылка](https://stackoverflow.com/questions/13387698/why-is-there-an-authorization-code-flow-in-oauth2-when-implicit-flow-works-s).
Лучший ответ, вторая половина (от "authorization code flow", выделенного полужирным). Но потребуется немного 
разобраться в разнице между HTTP и HTTPS.

При желании углубиться в особенности OAuth 2.0 можно обратиться к стандарту:
[ссылка](https://datatracker.ietf.org/doc/html/rfc6749). Или иному источнику информации на ваш вкус.

## Аутентификация по сертификату

Еще одним достаточно распространенным способом аутентификации является аутентификация по сертификату. Если 
большинство рассмортенных выше способов описывали процесс аутентификации отдельных запросов после первичной 
аутентификации по логину и паролю, то сертификат - это способ аутентификации без использования пароля в принципе.

Данный подход более характерен для интеграций между серверными приложениями, когда клиентом для сервера выступает не 
живой человек, а другой сервер. В реальной жизни такой способ аутентификации может быть предусмотрен в корпоративных 
системах с высоким уровнем требований к безопасности. За пределами этого сегмента лично мне встречалась 
аутентификация по сертификату разве что для доступа к VPN.

Обычно под аутентификацией по сертификату подразумевается аутентификация с использованием стандарта X.509. Такой 
сертификат может иметь различные репрезентации в виде файла - `.pem`, `.cer` и другие.

Мы не будем сильно углубляться во внутреннюю структуру сертификата и криптографическую составляющую. Обойдемся общей 
схемой работы, позволяющей верхнеуровнево понять принцип действия.

Обычно под сертификатом в узком смысле понимают цифровой документ (файл), который хранится у пользователя - в 
файловой системе, браузере, на USB-носителе, в ресурсах приложения (для интеграции между приложениями) и т.д. Такой 
файл содержит в зашифрованном виде информацию о владельце сертификата (пользователе), срок действия сертификата, а 
также ряд информации, позволяющей валидировать сертификат. Можно провести некоторые аналогии с токенами. Эти 
аналогии местами будут прослеживаться и далее.

С точки зрения процесса аутентификации стоит рассматривать три стороны: 

1. Клиент. То приложение, которое предъявляет сертификат в процессе аутентификации;
2. Целевой сервер. Приложение, которое получит сертификат в процессе аутентификации;
3. Удостоверяющий центр (Certificate Authority, CA). Отдельная система, которое подписало и выдало сертификат. В 
   самом сертификате содержится "подпись" CA и идентификатор СА. Главное условие - целевой сервер должен доверять CA,
   выдавшей сертификат.

Сам процесс аутентификации выглядит примерно так:

1. Клиент предъявляет сертификат целевому серверу;
2. Сервер валидирует сертификат: убеждается, что CA относится к доверенным, проверяет подлинности сертификата;
3. Сервер валидирует актуальность сертификата - проверяет, что он не истек и не был отозван удостоверяющим центром. 
   Последнее является аварийным механизмом в случае компроментации (утечки) сертификата к злоумышленникам;
4. Если все проверки прошли успешно - клиент считается аутентифицированным.

При желании разобраться в этой теме глубже - рекомендую начать изучение с
[RFC 5280](https://datatracker.ietf.org/doc/html/rfc5280), но это не та тема, которую легко освоить на хорошем 
уровне без дополнительной подготовки и хорошего понимания как минимум TLS/SSL - протоколов, обеспечивающих защищенность 
HTTPS в сравнении с HTTP.

## Двухфакторная аутентификация

**Двухфакторная аутентификация**, она же **Two-factor authentication**, она же **2FA** - общее название подхода к 
аутентификации, предполагающая несколько шагов аутентификации пользователя. Является частным и наиболее 
распространенным способом многофакторной аутентификации.

В наиболее распространенном сценарии первым шагом такой аутентификации является аутентификация по логину и паролю, 
вторым - аутентификация по одноразовому паролю в каком-либо виде.

Одноразовый пароль может быть получен различными способами. Наиболее распространенные из них:

1. Генерируемый пароль. Например, приложение, имеющее некий секретный ключ и генерирующее пароль на основании этого 
   ключа и текущего времени. Распространенный пример - Google Authenticator;
2. Одноразовый пароль, генерируемый внешним доверенным сервером. Сюда можно отнести различные Push-уведомления, коды,
   получаемые по SMS и т.д.;
3. Предопределенные пароли. Этот способ уходит в прошлое, но ранее был распространен для аутентификации в 
   онлайн-банкинг, социальные сети и т.д. Представляет собой пронумерованный список паролей, заранее предоставленных 
   пользователю (в личном кабинете, в виде отдельной физической карточки с паролями и т.д.). В качестве второго шага
   аутентификации необходимо ввести пароль по указанному номеру.

В зависимости от способа получения одноразового пароля определяется и способ его валидации. Суть такой 
аутентификации - определить, что пользователь не только знает основной пароль (или владеет иными данными для первого 
шага аутентификации), но и имеет доступ к некому доверенному носителю - приложению с зашитым секретным ключом, 
SIM-карте или предоставленному заранее списку паролей.

Отдельно можно выделить двухфакторную аутентификацию с аутентификацией по сертификату в качестве первого шага. В 
таком случае вторым шагом может выступать отдельный пароль или PIN-код, или же даже полноценная связка логин-пароль. 
Но такой подход однозначно не является широко распространенным, особенно за пределами корпоративных систем.

## Заключение

Статья охватывает достаточно большой перечень способов аутентификации, но покрывает далеко не все. В зависимости от 
требований в процесс аутентификации могут добавляться аппаратные ключи (например, в виде USB-флешки) или иные 
устройства, программные ключи, обеспечивающие адресный доступ к конкретным ресурсам с разрешения пользователя и иные 
способы.

Знакомство с новым механизмом аутентификации может сильно упроститься, если рассматривать его через призму проблем, 
которые конкретный механизм призван решить. Это добавляет осознанности при изучении и реализации, а при должной 
насмотренности - позволяет понять, какой способ лучше подойдет конкретной системе.

#### На сегодня все!

![img.png](../../../commonmedia/justTheoryFooter.png)

> Если что-то непонятно или не получается – welcome в комменты к посту или в лс:)
>
> Канал: https://t.me/ViamSupervadetVadens
>
> Мой тг: https://t.me/ironicMotherfucker
>
> **Дорогу осилит идущий!**

