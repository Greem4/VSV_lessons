# Сценарии обработки ошибок

Цель текущей статьи - разобраться с основными подходами к обработке ошибок в веб-приложениях.

Фактически, мы рассмотрим тему с двух сторон:

1. Теоретическое обоснование. Это необходимо, чтобы понимать актуальность тех или иных подходов, и проблематику, 
   которую эти подходы призваны решить. Здесь будет достаточно много разноплановой информации, н
2. Условно-практический. Он будет заключаться в изучении API, которое доступно для имплементации изученных подходов 
   в сервлетных приложениях. Эта часть интересна по двум причинам. Во-первых, на этом API могут базироваться 
   инструменты, которые актуальны в современной разработке. Во-вторых, даже при отличающемся API подходы остаются те 
   же. Т.е. сами различия в основном технические и любой новый набор интерфейсов изучить легче, если понимать, как 
   те же подходы реализованы где-то еще.

## Проблематика

При написании небольших программ обычно не возникает особых проблем с обработкой ошибок - синтаксические конструкции 
Java прекрасно справляются с этой задачей. Как в части непосредственной обработки исключений через `try-catch`, так и 
для оповещения о том, что что-то пошло не по плану через `throw`. Можно даже обязать пользователя какого-то 
контракта обязать обрабатывать определенные ошибки через механизм проверяемых исключений и `throws`. Казалось бы, 
что еще нужно для счастья?  

До тех пор, пока мы пишем небольшие учебные программы или даже разрабатываем реальный проект и пишем код какого-то 
отдельного класса или метода - действительно достаточно уже известного инструментария. Но как только мы поднимемся 
на уровень целого приложения, довольно быстро мы встретимся со следующим набором проблем:

1. Количество классов, отвечающих за взаимодействие с клиентом может исчисляться десятками и сотнями. Например, 
   несколько десятков сервлетов может быть даже в относительно небольшом приложении. И в каждом из этих сервлетов 
   могут возникать исключения. Если обрабатывать их в каждом сервлете отдельно, получится большой объем кодовой базы,
   который с большой долей вероятности не будет идентичен. То есть даже на одну и ту же (или однотипную) ошибку клиент 
   может получать разные ответы, в зависимости от того, какой запрос эту ошибку спровоцировал;
2. Код одной системы часто написан разными людьми в различное время. И каждый из этих людей может 
   встречаться с ситуациями, когда необходимо выбросить исключение в коде. При этом эти исключения могут как сильно 
   отличаться от уже существующих, так и быть схожими между собой. Скажем, при поиске сущности по идентификатору ее 
   не удается найти в БД. Есть ли разница, что за сущность мы ищем? В подавляющем большинстве случаев - нет. По 
   крайней мере, отображать такие ошибки клиенту скорее всего нужно одинаково. Но при этом код, выбрасывающий эти 
   ошибки может находиться в разных частях системы, быть написан разными людьми и в разное время;
3. Ошибки могут возникать в различных слоях архитектуры приложения. На уровне самого класса сервлета, в 
   бизнес-логике, в слоях, ответственных за коммуникацию с БД или с другими серверными приложениями и т.д. И чаще 
   всего ни в одной из этих слоев, кроме самого сервлета, нет доступа к объекту ответа. То есть единственный очевидный 
   способ сообщить сервлету об ошибке - вообще ее не трогать. Но это могут быть специфичные исключения - характерные 
   для конкретной БД или другого инструмента. И сервлет о таком виде ошибок может вообще не знать. Часто об 
   определенных исключениях не знает даже разработчик приложения - например, потому что это какая-то редкая ошибка, 
   вынырнувшая из недр библиотеки;
4. У одного серверного приложения может быть несколько клиентов для которых требуется различное представление 
   информации об одних и тех же ошибках. Это не слишком актуально, пока клиентом является браузер или 
   десктопное/мобильное приложение. Но если клиентами являются другие серверные приложения - проблема встает в 
   полный рост;
5. Может потребоваться идентификация ошибки для ее локализации и устранения. Скажем, в ситуации, когда пользователь 
   жалуется на сообщение об ошибке. В лучшем случае, все, что он может сказать - какие действия совершал перед 
   возникновением ошибки и показать доступную ему информацию об ошибке - будь то информация, отображенная на UI, или 
   результат запроса, доступных в инструментах разработчика в браузере. При этом чаще всего недопустима отправка 
   клиенту технической информации - стектрейса, названия возникшего исключения и т.д. Как минимум потому что эта 
   информация может быть использована злоумышленниками для определения стека технологий, используемого бэкендом и 
   дальнейшего подбора инструментов с учетом этой информации;
6. Для различных по своей сути ошибок может требоваться идентичная обработка перед передачей информации клиенту. При 
   этом признак, по которому способ обработки будет выбран может быть не всегда очевиден. Например, повторяемость. В 
   определенной системе может быть необходимо сообщить клиенту, что в случае одних ошибок повторять операцию 
   бесполезно, а в случае других - можно попробовать еще раз. Просто в силу того, что проблема краткосрочна и уже 
   через пару секунд может быть неактуальна.

Какие-то из этих проблем могут казаться очевидными, другие - не быть понятны до тех пор, пока не встретятся в 
реальности. Третьи могли быть вообще не упомянуты в данной статье. Но для решения всех этих проблем созданы 
различные решения - какие-то из них являются общепринятыми, какие-то противоречат друг другу и выбираются в 
зависимости от разрабатываемой системы. Или по предпочтениям конкретной команды разработки.

## Подходы к обработке исключений

### Глобальный обработчик ошибок

Глобальная обработка ошибок заключается в том, что на всю систему существует одна или несколько всем известных точек,
которые отвечают за обработку исключений. Каждая "точка" тут может быть как одним, так и несколькими классами. 
Главное, чтобы в пределах архитектуры приложения такие места были четко определены.   

Это не значит, что обрабатывать ошибки за пределами глобального обработчика нельзя - если исключение нужно лишь для 
того, чтобы обработать запрос пользователя нестандартным образом, но ответ на запрос все еще будет успешным (или 
условно-успешным) - никто не мешает использовать try-catch и отловить исключение. Особенно это актуально в случаях, 
когда исключение происходит в какой-то второстепенной логике, которая не должна прерывать выполнение запроса целиком.
Скажем, странно прерывать запрос на блокировку пользователя только потому что сервис взаимодействия с электронной 
почтой сломался и невозможно прямо сейчас отправить пользователю email о блокировке. Вполне вероятно, что логика 
отправки письма будет помещена в try-catch.

Но все те ошибки, о которых необходимо сообщать пользователю в ответе на запрос, должны иметь централизованную 
обработку. Это практически единственный подход в данной статье, которому не будет приведено альтернативы.

Обработка всех ошибок в одном месте позволяет:

1. Унифицировать сам процесс обработки. Т.е. для одинаковых исключений будет подготовлено одинаковое сообщение об 
   ошибке - независимо от того, где это исключение возникло. При этом логика обработки разных исключений может 
   отличаться в деталях - например, в зависимости от класса исключения. Достаточно того, что она сконцентрирована в 
   одном месте;
2. Упростить поддержку кода. Если необходимо сделать что-то в части обработки исключений или изучить, как это 
   работает в конкретной системе - разработчик всегда знает, где находится такая логика. Нет необходимости 
   перемещаться между разными классами на разных слоях архитектуры, чтобы собрать принцип обработки ошибок воедино;
3. Гарантировать надежность обработки ошибок. Если для всех запросов используется глобальный обработчик - достаточно 
   добавить обработку неизвестного (такого, для которого не определена специальная логика обработки) исключения и 
   это защитит от любых новых или неожиданных ошибок. Возможно, для каких-то исключений пользователь не получит 
   исчерпывающую информацию и в дальнейшем такой ошибке надо будет добавить собственную логику обработки. Но ситуация 
   останется контролируемой и не приведет к утечке лишних деталей об ошибке или иному нежелательному поведению системы.

Способ конечной реализации данного подхода зависит от стека технологий. Это может быть как полностью самописный 
обработчик, так и реализация на базе API, предоставленного фреймворком специально для таких ситуаций. Вне 
зависимости от этого, общая схема технической реализации общая:

1. Необходим класс, который получает управление раньше, чем отвечающий непосредственно за обработку конкретного 
   запроса. В случае с Servlet API за обработку конкретного запроса отвечает сервлет. А классом, который получит 
   управление раньше сервлета может выступать фильтр. Есть и другие варианты, но в данном случае это не так важно;
2. В таком классе (условно, фильтре) целевая логика запроса помещается внутрь try-блока. Таким образом появляется 
   возможность отловить любое исключение, которое возникнет в классе, ответственном за обработку запроса (условно, 
   сервлете) и далее по стеку вызовов;
3. catch-блок (или блоки) инкапсулируют в себе логику обработки возникшего исключения. Будет ли обрабатываться 
   `Exception` (или даже `Throwable`) или будет описана различная обработка под конкретные исключения - зависит от 
   требований к системе. Главная цель достигнута - создан механизм, позволяющий централизовано обработать ошибки для 
   любого пользовательского запроса.

В зависимости от стекатехнологий и конкретной реализации именно обработчика можно создать различные синтаксические 
обертки, позволяющие описывать саму логику обработки исключений с большим или меньшим комфортом.

> При изучении Spring мы познакомимся с реализацией, в которой разработчику приложения достаточно создать метод с
> определенной аннотацией, указать, какую ошибку он хочет обработать, и внутри этого метода описать саму логику
> обработки. В то время как встраивание такого метода в общий процесс обработки запроса, определение типа ошибки
> для передачи конечному обработчику и другие технические тонкости будут делегированы фреймворку.
> 
> На самом деле, даже в таком подходе есть возможность более тонкой настройки, но с этим мы будем разбираться в 
> соответствующей статье при изучении Spring Framework. 

Также может варьироваться ответственность разработчика в конфигурации обработчика. Так, в примере выше 
разработчик может вообще не отвечать за конфигурацию, полностью сфокусировавшись на логике формирования ответа 
пользователю при конкретном исключении. Но, например, в случае с реализацией глобального обработчика через фильтры в 
сервлетном приложении свободы намного больше:

1. Фильтр глобальной обработки исключений может быть ограничен специфическим маппингом. Например, чтобы не 
   отрабатывать на обращения к неизвестному ресурсу. Или наоборот не иметь подобных ограничений;
2. Фильтр может быть расположен первым в цепочке. Тогда он сможет обрабатывать исключения, возникшие при 
   работе других фильтров;
3. Фильтр может быть расположен последним в цепочке - тогда он будет отвечать только за исключения, возникшие в 
   сервлете и бизнес-логике.

Более детально особенности глобальной обработки исключений в сервлетных приложениях разберем в следующем пункте. Как 
минимум потому что Servlet API имеет собственный механизм для данной задачи, что позволяет вообще не создавать 
описанный выше фильтр.

### Бизнес-исключения

В данном случае речь пойдет о классах исключений, которые созданы в самом проекте, а не предоставляются Servlet API, 
JDBC или иными библиотеками. Такие исключения обычно создают для ситуаций, когда ошибка возникает непосредственно в 
бизнес-логике. Вы уже неоднократно создавали такие исключения в практической части предыдущих статей. Начиная с 
момента, как впервые познакомились с механизмом исключений.

Бизнес-исключения в абсолютном большинстве случаев являются непроверяемыми и наследуются от `RuntimeException`. Но с 
дальнейшим определением их иерархии есть несколько кардинально разных подходов:

#### Самостоятельные исключения

Наиболее простой и очевидный вариант. Для каждой исключительной ситуации создается свой класс исключения. 
Единственное, что будет объединять бизнес-исключения - скорее всего, все они будут наследниками `RuntimeException`.

Плюсов у такого подхода немного - скорость разработки и самодостаточность. Для каждого исключения можно завести 
собственный набор полей, если они нужны. А отсутствие какой-то внутренней иерархии и правил оформления позволит 
делать каждое исключение максимально гибким и подстраивать его под конкретную ситуацию.

Данный вариант имеет право на жизнь для небольших приложений или на этапе
[MVP](https://ru.wikipedia.org/wiki/%D0%9C%D0%B8%D0%BD%D0%B8%D0%BC%D0%B0%D0%BB%D1%8C%D0%BD%D0%BE_%D0%B6%D0%B8%D0%B7%D0%BD%D0%B5%D1%81%D0%BF%D0%BE%D1%81%D0%BE%D0%B1%D0%BD%D1%8B%D0%B9_%D0%BF%D1%80%D0%BE%D0%B4%D1%83%D0%BA%D1%82),
когда скорость разработки превалирует над качеством. Дополнительным плюсом в пользу данного подхода может быть 
гибкость обработки ошибок, предоставляемая фреймворком - скажем, тот же Spring позволяет через аннотацию над 
исключением указать код ответа, который должен получить клиент при возникновении данного исключения. Если большего 
не требуется - нет необходимости и усложнять сами исключения.

В случае если приложение растет, начинаются минусы:

1. Необходимо множество обработчиков для любой кастомизации ответа об ошибке. С какого-то момента кода ответа 
   становится недостаточно - требуется передать дополнительные сведения. Человекочитаемое сообщение, разного рода 
   метаинформацию. Или определить разный способ обработки разным исключениям. В таком случае кодовая база для 
   обработки исключений растет линейно от числа этих исключений. Может потребоваться дублировать или дополнительно 
   организовывать код обработки вручную - скажем, если одна группа исключений должна быть обработана одним образом, 
   другая - вторым, а все остальные - третьим;
2. Необходимо думать о логике обработки каждого исключения. Если обработка по умолчанию не подходит - необходимо 
   расширять кодовую базу, даже если нужный способ обработки уже описан для другого исключения;
3. Слабая поддерживаемость. Вполне вероятна ситуация, когда никто, кроме автора не будет знать, что такое исключение 
   существует. Или не будет знать, в каких ситуациях оно должно быть выброшено. А значит никто не сможет 
   переиспользовать это исключение. Для решения проблемы придется описывать документацию для каждого класса ошибки, 
   кроме самых очевидных;

На самом деле минусов у данного подхода может быть больше, но они специфичны как для конкретного проекта, так и для 
используемого стека технологий и выбранной архитектуры приложения.

### Иерархия исключений

Второй подход заключается в определении собственной иерархии (или нескольких иерархий), в которые встраиваются все 
бизнес-исключения.

Техническая реализация может быть различна - общий суперкласс, используемый самостоятельно для наиболее общих ошибок.
Абстрактный класс исключения или цепочки абстрактных классов - особенно, если бизнес-исключения обрастают 
дополнительными полями. Может быть даже организация иерархии, построенная на маркерных интерфейсах, которые 
определяют семантику обработки конечных исключений. Любые детали будут зависеть от проекта и задач, которые 
необходимо решить.

Плюсы такого подхода заключаются в первую очередь в решении проблем предыдущего:

1. Можно группировать логику обработки. Вероятно, необязательно описывать обработчик под каждое исключение, 
   достаточно привязаться к тому или иному суперклассу (или интерфейсу) в иерархии. Или опираться на значение 
   определенного поля исключения, если привязки по типу недостаточно;
2. Зона действия исключения может определяться местом в иерархии. Что, в свою очередь, дает дополнительную 
   информацию членам команды и позволяет лучше понимать, когда это исключение может быть переиспользовано.

Иерархия бизнес-исключений может быть внедрена в проект любых размеров.

Минусами данного подхода можно выделить:

1. Исключений может быть много и держать их в голове может быть сложно, несмотря на привязку в иерархии. В 
   результате чего со временем могут появляться исключения-дублеры. Лишь потому что кто-то не знал или не вспомнил 
   про уже существующее исключение для схожих ситуаций. В целом, это очевидно и для предыдущего подхода;
2. Сложность иерархии. Теперь нужно понимать внутреннюю логику иерархии, чтобы определить, к какому суперклассу 
   отнести каждый создаваемый класс исключения, если иерархия не сводится к единственному предку. Дополнительной
   проблемой могут быть дополнительные поля, определенные в предках - необходимо понимать логику заполнения каждого
   из них;
3. Более специфичный недостаток может возникнуть в ситуации, если серверное приложение работает с несколькими
   клиентскими, для которых необходимы различные сообщения об ошибках. В таких случаях для каждого клиента может 
   быть определен собственный "глобальный" обработчик ошибок. И в каждом из них придется описывать логику
   обработки под каждый класс (или суперкласс) исключения. Но системы с подобной спецификой относительно редки, а
   указанную проблему в принципе сложно решить в полной мере. Отчасти может помочь третий подход к организации
   бизнес-исключений, описанный ниже.

### Общее бизнес-исключение

В данном подходе бизнес-исключение всего одно - скажем, что-то нейтральное вроде `ApplicationException`.

Детализация информации об ошибке в таком случае происходит через поле такого исключения. Это поле, например, может быть 
енамом, который будет содержать информацию об ошибке в том или ином виде. В том числе может содержать код ответа для 
HTTP или просто уникальный идентификатор ошибки.

Для большей наглядности, ниже приведен небольшой пример.

Класс исключения

```java
public class ApplicationException extends RuntimeException {
    private final ErrorCode code;
    
    public ApplicationException(ErrorCode code) {
        this.code = code;
    }
    
    public ApplicationException(ErrorCode code, Throwable cause) {
       super(cause);

       this.code = code;
    }
    
    // Другие конструкторы, геттер для code и иной необходимый код
}
```

Примерный вид `ErrorCode` - фактический атрибутивный состав зависит от требований к конкретной реализации и может 
сильно варьироваться:

```java
public enum ErrorCode {
    NOT_FOUND(100, "Object not found", 404),
    // Коды могут быть как общими, так и специфичными. Внутренний идентификатор может нести дополнительную 
    // информацию о типе ошибки - скажем, коды, начинающиеся с 1 могут ассоциироваться с ненайденным объектом 
    CAR_NOT_FOUND(101, "Car not found", 404),
    DUPLICATE(200, "Object has duplicate", 500),
    // Коды для иных видов ошибки
    UNKNOWN(900, "Unknown error", 500);
    
    private final int id;
    private final String message;
    private final int httpCode;
    // Конструктор, геттеры для полей и иной необходимый код
}
```

Если для бизнес-исключений требуется определить несколько способов обработки, при текущем подходе не удастся 
привязаться к классу исключения - вместо этого привязку можно осуществить по коду, который упоминался выше. Или по 
диапазону кодов. Или по иному атрибуту, который доступен в пределах конкретного объекта ошибки.

Явными плюсами данного подхода можно выделить следующее:

1. Нет необходимости держать в голове иерархию исключений. Класс ошибки всего один, а конкретный код или иной 
   атрибутивный состав можно выбрать или расширить в енаме. Существующие типы ошибок доступны в одном месте, а не 
   разбросаны по пакетам;
2. Может решить проблему нескольких глобальных обработчиков, когда нужны специфичные сообщения разным клиентам - маппинг
   по значению енама или числовым кодам проще, чем по классам. Он как менее ограничен синтаксически, так и в целом
   более гибок - ведь у разных клиентов могут быть не просто разные требования к логике обработки, сами группы
   исключений могут формироваться по разным признакам.

Такой подход хорошо подходит для большинства приложений. Но он не лишен и ряда недостатков:

1. В целом, данный подход более многословный в использовании. Если необходимо выбросить исключение - надо не только 
   вызвать конструктор, но и в обязательном порядке передать параметр. Это приводит к усложнению читабельности кода. 
   Но, в целом, является наименьшим из недостатков текущего подхода;
2. Сам енам с кодами ошибок может сильно разрастаться со временем и быть сложным для поддержки. В том числе возможно 
   выделение кодов-дубликатов по аналогии с исключениями-дубликатами при подходе с иерархией;
3. Гибкость атрибутивного состава меньше, чем при иерархии или независимых бизнес-исключениях. То есть при 
   необходимости добавить какие-то специфичные для конкретного кода ошибки поля, могут возникнуть сложности. 
   Необходимость в подобных расширениях случается нечасто и технически решаема даже в такой модели работы. Но 
   иерархия исключений больше подходит для подобных ситуаций;
4. Меньшая расширяемость решения в сравнении с иерархией. Пока класс исключения и коды ошибок относятся к кодовой 
   базе проекта - все хорошо. Но если они вдруг сепарируются - например, выносятся во внутреннюю библиотеку, которую 
   используют несколько модулей продукта, ситуация резко ухудшается. Для иерархии исключений это не проблема - 
   в конечном проекте всегда можно определить свои классы-наследники. Для текущего подхода это придется решать через 
   превращение `ErrorCode` в интерфейс и определение енамов-наследников этого интерфейса внутри библиотеки и в 
   конечном проекте. Но даже это усложняет общую модель взаимодействия в сравнении с базовым описанием.

В конечном итоге для конкретного приложения может быть выбран как один из подходов выше, так и какой-то 
промежуточный вариант - например, простая иерархия исключений с дополнительной идентификацией конкретной ошибки 
через енам. Или наоборот подход с одним бизнес-исключением, но постепенным выделением наиболее популярных видов 
ошибок в отдельные исключения для лаконизации их создания.

### Проброс и преобразование исключений

Могут возникать ситуации, когда реальное исключение - это ошибка уровня БД или ошибка обращения к стороннему серверу.
Обычно такие исключения являются проверяемыми. Или же описываются стандартные механизмы проверки на ошибку в ответе 
(в случае с обращением к внешнему сервису).

Обработка таких исключений обычно заключается в их логировании в catch-блоке и пробросе уже бизнес-исключения, которое в
`cause` будет содержать изначальную ошибку.

Такая операция может быть актуальна по двух причинам:

1. Избавиться от `throws` в сигнатуре. Это актуально для большинства ситуаций, когда происходит работа с внешними 
   ресурсами. Нет смысла сохранять `throws` вплоть до сервлета - скорее его стоит обработать как можно ближе к 
   непосредственной работе с ресурсом. В ряде случаев это на себя возьмет библиотека, в оставшихся - имеет смысл 
   сделать самостоятельно;
2. Оригинальное исключение неинформативно для глобального обработчика. Каким бы расширенным не был обработчик, он не 
   может (и не должен) знать вообще о любом исключении, которое может теоретически возникнуть в системе. 
   Соответственно, есть смысл обернуть специфическое исключение в бизнес-ошибку там, где контекст оригинальной 
   ошибки понятен. Обработчик будет работать уже с бизнес-исключением, но при необходимости сможет получить доступ к 
   изначальной ошибке через `Throwable#getCause()`.

Обертывание низкоуровневого исключения более высокоуровневым - крайне распространенный подход, который применяется и 
на уровнях библиотек, и в конечных проектах. В каком-то смысле это шаг в сторону от единого глобального обработчика. 
С другой стороны, этот подход облегчает сам обработчик без потери информации. Более того, бизнес-исключение может 
быть даже более информативным, поскольку может указать на привязку к бизнес-логике, при исполнении которой возникла 
изначальная ошибка. Низкоуровневые исключения могут быть информативны в своей зоне ответственности, но не всегда дают 
достаточно информации, чтобы понять картину целиком.

### Логирование

Данный пункт не связан напрямую с исключениями и не ограничивается серверной частью веб-приложений.

Логирование является основным способом для сохранения информации об ошибке. Именно с логов начинается работа с 
любой неожиданной ошибкой, обнаруженной в работе приложения. Здесь нас могут интересовать следующие моменты:

- Логирование ошибки при ее обработке - будь это глобальный обработчик или иное место в коде. Даже если мы отловили 
  исключение для какой-то побочной логики, ошибка в которой не должна прерывать выполнение запроса, стоит залогировать
  сам факт ошибки, ее имя и стектрейс. При необходимости - снабдить лог дополнительной информацией с описанием 
  контекста ошибки. Благо, SLF4J предоставляет удобный API для таких ситуаций;
- Логирование ошибки на клиенте. Это может дать дополнительную информацию о проблеме или восстановить более 
  целостную картину. Но есть проблема. Так как клиентом в наиболее классическом случае выступает браузер - 
  доступ к логам реального пользователя чаще всего невозможен в привычном виде - доступа к компьютеру реального 
  пользователя нет. Вместо этого клиентские приложения могут сами отправлять информацию о произошедших ошибках. 
  Существуют даже специализированные продукты для таких задач. Например, [Sentry](https://sentry.io/). Работа с 
  этими продуктами - задача фронтенд-разработчика. Но информация из таких логов может быть полезна и для поиска 
  проблем на бэкенде.

В целом тема логирования в части работы с ошибками достаточно широка. Тут можно рассматривать и целесообразность 
добавления контекста для конкретного потока выполнения, например, чтобы в логе явно указывалось, какой запрос 
обрабатывается, для какого пользователя и т.д. В качестве контекста может выступать любая информация, которая может 
упростить локализацию проблемы.

Сюда же можно добавить и трейсинг для распределенных систем, что позволяет локализовать ошибку даже если изначальный 
запрос обрабатывался множеством серверов, которые так или иначе передавали его друг другу.

В данную тему каждому придется погружаться со временем, по мере углубления эксепертизы в разработке.  

### Код ответа

Финальный пункт в теоретической части статьи - работа с кодом ответа в HTTP.

На первый взгляд, все достаточно просто. Существует спецификация, описывающая семантику HTTP. Определены коды 
ответов для различных ситуаций - в том числе для различных типов ошибок. Но есть нюанс.

Фактически, можно выделить два основных подхода с кодом ответа:

1. Очевидный. Для успешных ответов отправляются `2хх` коды (чаще всего - `200`). Для ошибок клиента и сервера - `4хх` и 
   `5хх` соответственно. Полный перечень используемых кодов зависит от дотошности команды или требований к API;
2. Фактически отказ от HTTP-кодов. В таком случае на любой вопрос сервер отвечает кодом `200`. Если произошла ошибка -
   она будет описана в теле ответа. Одна из главных особенностей такой реализации заключается в стандартизации 
   тела ответа - контракт всегда будет подразумевать отдельное поле в ответе, отвечающее за полезную нагрузку при 
   успешном выполнении запроса. И отдельное - для передачи информации об ошибке. В последнем обычно фигурирует код 
   ошибки, принятый на сервере, сообщение об ошибке и, по необходимости, какая-либо дополнительная информация.

Первый подход прост и базируется на конкретных документах. Но почему какие-то альтернативы вообще живы?

Аргументов за второй подход можно выделить несколько:

1. Если запрос дошел до сервера - это уже успех. Звучать может забавно, но такой тезис имеет практический смысл: 
   если клиент получает любой код, отличный от `200` - это однозначный маркер проблем с инфраструктурой. Сетевая 
   доступность, ошибки настройки прокси-сервера, упало само серверное приложение - неважно. В любом случае, это не 
   проблема бэкенда в узком смысле, проблему надо искать не в коде;
2. HTTP-код не информативен. При условии, что клиент должен по-разному реагировать на разные бизнес-ошибки, перечень 
   HTTP-кодов оказывается кратно (или на порядке) меньшим, чем число потенциальных ошибок на сервере. То есть даже в 
   привычном подходе при получении 4хх или 5хх кода клиент будет вынужден лезть в тело ответа за детальной 
   информацией - например, уникальным кодом ошибки. А если клиент в любом случае должен обработать тело - зачем 
   дополнительно завязываться на HTTP-код?
3. Приложение работает не только по HTTP. Сетевая коммуникация имеет несколько популярных протоколов различного 
   уровня абстракции. Что логично, далеко не все из этих протоколов оперируют моделью "запрос-ответ", не все 
   нуждаются и в статусе ответа. Отсюда слабым, но аргументом, в пользу подхода "все по 200" может выступать 
   единообразие моделей ответов на сервере для разных протоколов.

Недостатки такого подхода в основном так или иначе связаны с тем, что он противоречит спецификации. Из-за чего могут 
нарушаться или требовать доработки различные элементы веб-приложения в целом - от некорректной обработки результатов 
запроса браузером, до нарушений работы систем мониторинга, логирования и оповещения о проблемах.

На данном этапе кажется достаточным просто узнать о существовании такого подхода. Свое личное отношение к нему лучше 
формировать, базируясь на личном опыте и прикладных задачах, решение которых склоняет чашу весов в пользу одной из 
описанных концепций.

## Servlet API

Рассматривая инструменты для обработки ошибок в сервлетных приложениях стоит начать с механизма по умолчанию - 
скорее всего, каждый уже не раз встречал окно, похожее на это:

![img.png](./tomctDefaultErrorPage.png)

Любой контейнер сервлетов имеет механизм по умолчанию для представления клиенту информации об ошибках. В случае с 
Tomcat - это страница с указанием кода ошибки, описанием проблемы, какой-то дополнительной информацией - например, 
для 5хх кодов будет отображен стектрейс исключения.

Что же с альтернативами?

### Общие пункты

Большая часть информации, описанной выше, не имеет жесткой привязки в Servlet API. Иерархия исключений, модель 
работы с HTTP-кодами, логирование - эти вещи легко реализовать без каких-то дополнительных инструментов, опираясь на 
уже изученные возможности сервлетных приложений.

Остается реализация глобального обработчика ошибок. Как взаимодействовать с самим обработчиком рассмотрим ниже, а 
пока разберемся с тем, что может выступить в роли сообщения об ошибке клиенту.

Фактически, варианта 2:

1. Информация об ошибке в виде JSON или в ином формате с последующей обработкой клиентским приложением. В таком 
   случае задача обработчика - сформировать сообщение об ошибке в выбранном формате и записать его в тело ответа. В 
   зависимости от подхода к работе с HTTP-кодом сюда же относится и установка кода ответа, если необходимо;
2. Перенаправление на страницу ошибки. В данном случае логично воспользоваться `RequestDispatcher#forward()` и 
   неявно перенаправить запрос на страницу, которая связана именно с данной ошибкой.

В обоих случаях выбор конкретного сценария обработки зависит от требований, выбранной модели бизнес-исключений и 
специфики конкретной ошибки. В любом случае это будет тривиальная логика, которую можно построить либо на 
множественных catch-блоках (наименее удобный сценарий), либо на проверке типа исключения обработчиком (например, 
через `instanceof`), либо на проверке конкретных атрибутов объекта исключения. При необходимости могут быть 
задействованы атрибуты запроса.

Осталось рассмотреть способы создания обработчика.

### Фильтры

Как уже было сказано ранее, можно определить собственный глобальный обработчик ошибок через функциональность фильтров.

Место фильтра в цепочке будет зависеть от желаемого результата - должен ли обработчик захватывать ошибки, 
возникшие в других фильтрах.

Вторая особенность будет заключаться в особенностях маппинга. Технически, можно определить различные обработчики для 
разных сервлетов. Например, если они доступны для разных клиентских приложений и требуют различной обработки для 
одних и тех же ошибок.

Сам код фильтра будет выглядеть примерно так:

```java
public class ExceptionHandlingFilter extends HttpFilter {
    @Override
    protected void doFilter(HttpServletRequest req, HttpServletResponse res, FilterChain chain) {
        try {
            chain.doFilter(req, res);
        } catch (Exception e) {
            handleException(req, res, e);
        }
    }
}
 
```

`handleException()` внутри себя будет содержать всю необходимую логику обработки ошибок - проверки типов, 
определения способа обработки ошибок, формирование сообщения об ошибке или перенаправление на страницу ошибки. 

Логика обработчика достаточно тривиальная и в базовом виде не имеет каких-то сложностей в реализации.

Единственное, что стоит отметить - если необходимо, чтобы такой обработчик был актуален для ситуаций, когда ресурс не
найден - стоит определить сервлет, с маппингом на `/*`. Задачей такого сервлета будет выбрасывание исключения и 
установка кода `404`. Потому что в ином случае код `404` установит контейнер сервлетов. Но нинакого исключения он не 
выбросит и catch-блоку будет нечего отлавливать. 

### Встроенный механизм работы с ошибками

Подход с обработкой ошибок в фильтре может быть актуален и в современных приложениях - они, зачастую, не имеют 
дескриптора развертывания и в принципе довольно мало используют возможности Servlet API. Даже сама модель работы с 
контейнером сервлетов несколько отличается от той, которую мы рассматривали в этом разделе.

Тем не менее Servlet API предоставляет свой механизм для обработки ошибок. В чем-то даже более интересный, чем 
описанное выше решение. Как минимум, он не требует костылей вроде сервлета по умолчанию для обработки `404` кода.

В статье, посвященной знакомству с `web.xml`, был описан тег `<error-page>`. Он примечателен тем, что позволяет 
декларативно указать ресурс, на который должно произойти перенаправление в случае, если при обработке запроса 
возникла ошибка. При этом:

1. Целевой ресурс можно привязать к конкретному классу исключения или коду ответа. То есть можно не определять 
   целевой ресурс вручную, лишь прописать маппинг. Перенаправлениями займется контейнер сервлетов;
2. Ресурсом может выступать что угодно. Как HTML/JSP-страница, так и сервлет. Таким образом, при желании можно 
   выделить специальный сервлет, который будет отвечать только за обработку ошибок, возникших при попытке доступа к 
   другим ресурсам;
3. Контейнер сервлетов сам соберет информацию о случившемся - добавит несколько атрибутов запроса с указанием типа 
   исключения, самого объекта исключения, информацией о целевом запросе и имени сервлета, в котором возникла ошибка.

Выглядеть это может следующим образом.

Расширяем `web.xml`:

```xml
<servlet>
    <servlet-name>ExceptionHandlingServlet</servlet-name>
    <servlet-class>com.walking.sample.servlet.HelloWorldServlet</servlet-class>
</servlet>

<servlet-mapping>
    <servlet-name>ExceptionHandlingServlet</servlet-name>
    <url-pattern>/error</url-pattern>
</servlet-mapping>

<error-page>
<!--При желании можно добавить привязку к конкретному коду ответа-->
<!--<error-code>500</error-code>-->
<!--При желании можно добавить привязку к конкретному классу исключения-->
<!--<exception-type>java.lang.RuntimeException</exception-type>-->
    <location>/error</location>
</error-page>
```

Здесь мы регистрируем новый сервлет, определяем маппинг для него, определяем `<error-page>`, которая ссылается на 
маппинг сервлета. Так как для `<error-page>` не указано конкретного HTTP-кода или типа исключения, указанный путь 
будет использован для любого 4хх или 5хх кода и любого возникшего исключения.

Код сервлета-обработчика можно определить, например, так:

```java
public class ExceptionHandlingServlet extends HttpServlet {
    @Override
    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        handleException(req, resp);
    }
}
```

В данном случае тело `handleException()` будет таким же, каким было бы в обработке исключений через фильтр.

Обратите внимание, что в данном случае был переопределен не один из do-методов, а общий метод `HttpServlet#service()`.
В основном для того, чтобы не переживать за выбор HTTP-метода - ведь при обработке ошибки для нас вряд ли будет 
значение выбранный пользователем метод HTTP. А дублировать однотипный код для каждого из методов не имеет особого
смысла.

Вторая особенность заключается в том, что доступ к исключению осуществляется через атрибуты запроса. Если 
запрос был обработан с той или иной ошибкой, контейнер сервлетов обязан поместить в объект запроса следующие 
атрибуты*:

- `jakarta.servlet.error.exception`. Содержит объект исключения в случаях, если оно существует. Как было описано в 
  предыдущем пункте статьи, исключения может и не быть;
- `jakarta.servlet.error.status_code`. HTTP-код ответа, сформированный сервлетом или контейнером. Для исключений по 
  умолчанию `500`, для не найденного ресурса - `404`, остальные обычно зависят от логики приложения; 
- `jakarta.servlet.error.exception_type`. Устаревший атрибут. Содержит объект `Class` для возникшего исключения. 
  Стал бесполезен в момент, когда появился `jakarta.servlet.error.exception`;
- `jakarta.servlet.error.message`. Аналогичен вызову `getMessage()` у объекта исключения. Устаревший атрибут;
- `jakarta.servlet.error.request_uri`. URI оригинального запроса. Стандартным способом через 
  `HttpServletRequest#getRequestURI()` извлечь его не удастся - там уже будет URI `ExceptionHandlingServlet`;
- `jakarta.servlet.error.query_string`. Теоретически должен содержать значение, аналогичное 
  `HttpServletRequest#getQueryString()`. Но Tomcat его не заполняет, при этом стандартный способ через метод 
  объекта запроса остается рабочим;
- `jakarta.servlet.error.servlet_name`. Имя ресурса, который обрабатывал этот запрос ранее. В случае, если ресурс не 
  был найден - будет значение-заглушка. 

> *Актуальный список и ключи зависят от версии Servlet API. Список выше актуален для 6.1.

Как можно понять по списку выше, контейнер сервлетов предоставляет исчерпывающую информацию о запросе и ошибке, что 
позволяет без каких-либо ограничений описывать дальнейшую логику обработки исключительной ситуации. 

На этом мы завершаем рассмотрение обработчиков ошибок на базе Servlet API.

## Заключение

Данная статья фактически является последней в разделе, посвященном знакомству с Web и Java EE.

В Road Map можно заметить заготовку под еще одну тему, посвященную механизму асинхронной обработки запросов в 
сервлетных приложениях. Но она является теоретической и будет рассмотрена на заключительном этапе всего курса.

Впереди нас ждет еще много взаимодействия с веб-приложениями и, в общем-то, сервлетными приложениями в широком 
смысле слова. Но оперировать мы будем, преимущественно, инструментарием, который предлагает Spring Framework.

Текущий раздел получился крайне насыщенным, из-за чего материал может показаться где-то сложным, где-то - слишком 
поверхностным. И если вам так показалось - скорее всего, вам не показалось:)

Большая проблема перехода от изучения непосредственно Java (или даже Java + СУБД) к вебу и бэкенд-разработке в том, 
что сам веб - весьма сложен по своему внутреннему устройству и тем инструментам, которые существуют для 
взаимодействия с ним. Если в части консольных и десктопных приложений начинающий разработчик фактически находится в 
привычном окружении - родной операционной системе - и базируясь на предыдущем опыте работы с ПК может понять большую 
часть изучаемых тем, то при переходе к веб-разработке все меняется. Теперь окружением является Сеть, протоколы и 
механизмы которой для большинства непонятны даже на базовом уровне. При этом уровень погружения во внутреннее устройство
этого окружения требуется более глубокий, чем при разработке десктопных или консольных приложений.

Из-за смены окружения, в котором будет работать программа, приходится изучать слишком много новых технологий и 
подходов - от модели клиент-сервер до протоколов сетевого взаимодействия. И лишь на этом базисе вновь учиться 
использовать Java для решения каких-либо задач, учитывая и новый контекст, и новые технологии, которые необходимо 
применять в разработке.

Эту информацию с разных точек зрения и с прицелом на формирование целостной картины мира эту стараются давать на
профильных специальностях в ВУЗах. Но даже при подобной подготовке зачастую получается сформировать у студентов лишь
базовую и обрывочную картину устройства сетей (и, в частности, Интернета) и подходов к разработке веб-приложений. Как
часть одного, пусть и большого, курса передать даже ВУЗовский объем информации малореально по разным причинам - в том 
числе потому что придется слишком много писать о скучных для новичков вещах, прикладная ценность которых с их уровня 
знаний будет казаться примерно такой же, как ценность высшей математики для слесаря.

Из-за этого приходится прыгать через голову, стараясь донести минимальный и, во многом, недостаточный набор знаний, 
который позволит хоть как-то применять их на практике в разработке серверных приложений. И основной минус такого 
подхода в том, что огромный мир, в котором будет разрабатываться и жить ваше серверное приложение, вам предстоит 
изучить самостоятельно. С разочарованиями от понимания ограниченности своих познаний, с ошибками из-за непонимания 
или превратного понимания каких-то фундаментальных принципов или подходов.

С другой стороны, все это остается безумно интересным, а набитые шишки приводят к лучшему пониманию причин, почему 
все устроено так, как устроено. В конечном итоге это может дать большую скорость развития специалиста, нежели 
профильное образование. Если хватит упрямства и запала. Если найти в себе силы учиться дальше, переживать и 
прорабатывать собственные пробелы в знаниях. Если признавать свои ошибки и с каждым разом пытаться сделать лучше и с 
большим уровнем осознанности.

И я очень надеюсь, что это получится у каждого, кто дошел до этой статьи. Потому что уже многое позади. И осталось не 
так много до финишной черты. За которой будет новая дорога.

Дальнейшие разделы во многом проще пройденного материала - с одной стороны там будут достаточно сложные концепции и 
большой объем нового API, с которым придется научиться работать. С другой - основные два раздела, которые остаются в 
курсе, посвящены прикладным инструментам разработки, базирующимся на уже изученных библиотеках и спецификациях.
То есть будет меняться лишь инструментарий, а не окружение для работы изучаемых инструментов. К тому же, большая часть
тем впереди - то, с чем придется сталкиваться на реальных проектах. То, о чем придется рассказывать на собеседованиях.
В конце концов, то, за чем многие пришли на этот курс.

#### С теорией на сегодня все!

![img.png](../../../commonmedia/defaultFooter.jpg)

Переходим к практике:

## Задача

Доработайте приложение, разработанное на базе практики к статьям 147-151.

Необходимо:

1. Добавить собственную страницу, на которую будет добавлен редирект в случае, если ресурс по заданному пути не 
   существует - обработка 404 кода ответа;
2. Для случаев, когда пользователь передал некорректные данные в запрос - т.е. тело запроса не удалось 
   десериализовать в ожидаемый объект, сервер должен отдавать 400 код ответа, тело ответа должно содержать читаемое 
   сообщение об ошибке;
3. В случае, если на сервере было выброшено любое бизнес-исключение - сервер должен отдавать 500 кодом ответа, в 
   теле ответа должна быть представлена читаемая информация об ошибке без технических деталей;
4. В случае, если произошла любая иная ошибка - сервер должен отдавать 500 код ответа, в теле ответа должно быть 
   сообщение о неизвестной ошибке.

Ветка для PR: [for-pr](https://github.com/KFalcon2022/car-servlet-practical-task/tree/for-pr/exception-handling).

**Разбор практики для этого урока**:
[ссылка](https://github.com/KFalcon2022/car-servlet-practical-task/tree/solution/exception-handling)

> Если что-то непонятно или не получается – welcome в комменты к посту или в лс:)
>
> Канал: https://t.me/ViamSupervadetVadens
>
> Мой тг: https://t.me/ironicMotherfucker
>
> **Дорогу осилит идущий!**
