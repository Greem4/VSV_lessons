# Servlet API. ServletConfig. ServletContext. Слушатели событий

Рассматриваемые сегодня инструменты интересны в первую очередь концепциями, на которых они базируются. Сами
интерфейсы и классы специфичны для сервлетных приложений и их глубокое изучение не принесет особой выгоды в
прикладной разработке на современном стеке технологий. Но с теми же паттернами и подходами, которые применены в этих
классах, мы будем сталкиваться постоянно.

## ServletConfig

`ServletConfig` - интерфейс, один из предков сервлета, который предоставляет API по получению информации о сервлете:

1. Имени сервлета (`getServletName()`);
2. Контекста сервлетов (`getServletContext()`) - его подробнее разберем ниже;
3. Параметров инициализации сервлета. Последние представлены в строковом виде и доступны по определенным для них
   ключам (`getInitParameter(String name)`). Также можно получить перечень ключей параметров, определенных для
   сервлета (`getInitParameterNames()`).

Несложно заметить, что API достаточно простое и может встать несколько вопросов. Скажем, зачем для этих методов
выделять отдельный интерфейс - они достаточно гармонично смотрелись бы и в самом интерфейсе `Servlet`. Или же зачем
в принципе нужны параметры инициализации - мы видели, что их можно определять в `web.xml`, но чем это отличается от
обычных констант в классе сервлета?

Ответом на первый вопрос может служить разделение ответственности логики класса - сервлета - и логики конфигурации
класса. Последнее, собственно, и отдается на откупа `ServletConfig`. Это разделение отчасти искусственное, но часто
может быть полезным - отделение конфигурации теми или иными средствами оставляет больше гибкости для разработчика. В
случае с Servlet API тяжело оценить это в полной мере, поскольку конфигурация сервлета все равно будет делегирована
контейнеру сервлетов и скрыта от разработчика. Но в других ситуациях этот подход можно брать на вооружение.

> В принципе, мы уже встречали эту концепцию, но в несколько другой реализации - центральный класс инструмента миграций
> Flyway - собственно, класс `Flyway` может быть создан через отдельный класс `FluentConfiguration`, который
> отвечает за сбор параметров, в дальнейшем передаваемый объекту `Flyway` при инициализации.

Остается вопрос ценности параметров инициализации как таковых. Выгода параметров инициализации перед константами класса
более очевидна - в случаях, когда параметры инициализации вообще необходимы:

1. Для `web.xml` (обычно и для других файлов конфигурации) доступны ссылки на переменные окружения в формате `$
   {paramName}`, где `paramName` - имя переменной окружения. Это позволяет для разных исполняемых сред менять нужные
   параметры на уровне конфигурации сервера*, не затрагивая кодовую базу. Причем эти переменные могут быть определены
   в одном файле, что намного удобнее, нежели изменение кодовой базы множества классов под каждое окружение;
2. Локализация параметров инициализации в одном файле. Приложение может содержать десятки и сотни сервлетов. Искать
   в них какие-то переменные или константы, не факт, что определенные в одном стиле и очевидные при первом чтении,
   не так удобно, как открыть тот же `web.xml` и просмотреть или актуализировать нужные значения.

> *Строго говоря, конфигурация сервера - последнее, что будет использовано для указанной цели. Более вероятна
> конфигурация параметров на уровне JVM. Менее вероятно именно для сервлетных приложений, но возможно -
> переменные операционной системы, в которой развернут сервер.

## Понятие контекста. ServletContext

С контекстом все намного интереснее. Это крайне популярная концепция для объектно-ориентированных языков
программирования, имеющая массу областей применения. Поэтому начать придется издалека.

Часто приложению необходимо в том или ином виде хранить некое состояние программы* на уровне всего приложения или
конкретного потока исполнения. Например, параметры конфигурации, которые будут использоваться несколькими различными
библиотеками или просто участками кода. Или же какие-то промежуточные (или, наоборот, неизменяемые) данные внутри
глобального процесса обработки иных данных. Иными словами, _контекст_, в котором будет выполняться процесс
обработки данных/пользовательского запроса/работа программы в широком смысле этого слова.

> Состояние программы, глобальное состояние, просто "состояние" - здесь и далее используются как взаимозаменяемые
> термины. Представляет собой некий набор значений или объектов.
>
> В разрезе контекста - та информация, которую конкретный контекст хранит внутри себя.

Различных примеров можно привести много, в зависимости от того, какое именно приложение мы будем рассматривать.
В любом случае, это состояние необходимо каким-то образом хранить и обеспечивать доступ к нему.

### Пример

Если рассматривать клиент-серверное приложение с аутентификацией, то достаточно наглядным примером может быть
информация о текущем пользователе при обработке HTTP-запроса.

Пользователь может отправлять различные запросы, для обработки которых может потребоваться разной сложности логика.
И по множеству причин нам может быть полезно знать, что это за пользователь - проверка прав доступа к определенной
сущности, различные сценарии обработки одного запроса в зависимости от роли этого пользователя, банальное
сохранение информации об авторе сущности при ее создании и/или сохранении в БД.

Как правило, мы имеем доступ к информации о пользователе на этапе получения запроса - например, можем получить из
запроса сессию и по ней вычислить конкретного юзера. Но далее обработка запроса перейдет сервисным или иным
классам, отвечающим за бизнес-логику и там уже не будет доступа к объекту запроса, из которого можно извлечь
сессию. А информация о пользователе все еще нужна.

Передавать данные юзера параметрами методов - очевидный, но очень неудобный путь. Это сильно усложняет код,
повышает вероятность ошибки. Альтернативно - мы можем поместить информацию о том, что текущий поток обрабатывает
запрос конкретного пользователя в отдельное хранилище. И каждый раз, когда нам необходимо получить информацию о
текущем пользователе - обращаться к этому хранилищу. В таком случае для получения пользователя достаточно знать, в
каком потоке исполнения мы находимся. А эта информация всегда доступна через `Thread.currentThread()`.

На самом деле именно описанная проблема обычно решается через `ThreadLocal` и надстройки над ним, но само ее
описание позволяет лучше понять актуальность сохранения состояния хотя бы в рамках отдельного потока.

### Проблематика

До тех пор, пока мы используем процедурные языки или иные парадигмы, где нет такого выраженного стремления к
инкапсуляции, как в ООП - все хорошо. Мы можем создавать переменные или константы, доступные из любой точки
приложения, и использовать их. Фактически, даже в таких языках этот подход будет плохой практикой, но проблему
сохранения глобального состояния он решает.

Но как только мы приходим к ООП, глобальные переменные становятся недопустимы - они противоречат самой концепции ООП
и принципу инкапсуляции. Вместо них нужен какой-то класс, объект(-ы) которого:

1. Позволит хранить необходимое состояние - переменные, объекты и что угодно еще, в зависимости от зоны
   ответственности этого класса;
2. Будет предоставлять API, ограничивающее бесконтрольное изменение состояния и удобное для получения необходимых
   данных;
3. Будет легкодоступен в пределах своей зоны ответственности - приложения, потока, транзакции БД, определенного слоя
   архитектуры и т.д.

Собственно, класс, выполняющий условия выше обычно и называется контекстом. За пределами текущего раздела чаще всего
мы будем сталкиваться с этим термином в Spring, также в отдельных случаях он будет применяться при знакомстве с
Hibernate. В целом же сфера применения этой концепции крайне широка и актуально для большинства сколь-либо крупных
фреймворков. В несколько другом смысле самостоятельный термин "контекст" может применяться в описании архитектурных
подходов и иных темах, но в данном курсе это вряд ли будет затронуто.

### ServletContext

Как было указано в предыдущих статьях, в Servlet API контекст - класс, отражающий глобальное состояние всего
сервлетного приложения. Он позволяет управлять и предоставляет доступ практически ко всему, что так или иначе
связано с приложением.

Ниже будет тезисный разбор API `ServletContext`. Направлено оно не столько на знакомство с конкретными методами, 
сколько на формирование понимания, как может выглядеть конкретный контекст с точки зрения кода.

#### Взаимодействие с сервлетами

`ServletContext` предоставляет несколько ключевых методов, прямо связанных именно с сервлетами:

1. `addServlet()`. Позволяет программно добавить сервлет. В дополнение к регистрации через `web.xml` и `@WebServlet`.
   Примечательным здесь является то, что одна из перегрузок этого метода позволяет передать сам объект сервлета. Что,
   соответственно, позволяет создать объект самостоятельно и проинициализировать его привычным способом - через 
   конструктор, а не `Servlet#init()`. В ситуации, когда в полях сервлета есть классы бизнес-логики это сильно 
   упрощает их инициализацию. Каким образом - станет понятнее, когда мы познакомимся
   с [инверсией управления](https://ru.wikipedia.org/wiki/%D0%98%D0%BD%D0%B2%D0%B5%D1%80%D1%81%D0%B8%D1%8F_%D1%83%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F)*;
2. `createServlet()`. Метод для создания объекта сервлета по переданному объекту `Class`. Внутри этого метода будут
   проанализированы аннотации вроде `@WebServlet` и других подобных, что позволяет сразу корректно настроить объект
   с точки зрения контейнера сервлетов.
3. `getServletRegistrations()`. Предоставляет информацию обо всех зарегистрированных сервлетах в виде `Map`. Ключом 
   выступает имя сервлета, а значением - объект `ServletRegistration`, через которую можно получить информацию о 
   сервлете или обновить ее. К такой информации относятся маппинги путей, правила инициализации и ряд других 
   конфигураций. К слову, такой же объект возвращает и `addServlet()`, что необходимо для конфигурации программно 
   добавляемого сервлета;
4. `getServletRegistration()`. Метод похож на предыдущий, но возвращает информацию о конкретном сервлете по имени, 
   переданному параметром;

> *Утрировано, **инверсия управления** (**Inversion of Control**, **IoC**) - паттерн, имеющий несколько типовых 
> реализаций, предназначен для гибкого создания и/или получения объектов конкретных классов. Обычно применяется для 
> классов логики.
> 
> Это ключевая концепция, вокруг построен Spring и некоторые другие фреймворки. Хорош тем, что позволяет не 
> думать о порядке создания объектов для классов логики. Что крайне полезно в ситуациях, когда одни сервисы 
> (репозитории, мапперы, любые другие классы логики) зависят от других, которые зависят от третьих... Прописывать 
> эту логику в ручном режиме утомительно, еще сложнее - поддерживать такую кодовую базу. В то время как 
> использование IoC позволяет почти полностью автоматизировать данный процесс.

Стоит понимать, что данные методы достаточно продвинутые и в большинстве своем предназначены для ситуаций, когда 
сервлетное приложение конфигурируется с использованием других спецификаций Java EE. Их совместное использование 
позволяет сильно упростить инициализацию отдельных классов сервлетов. Но эти спецификации и их имплементации - не 
основной подход в глазах современной разработки, поэтому углубляться не будем. Для нас описанные выше методы 
интересны в первую очередь для понимания возможностей конкретного контекста в принципе.

#### Взаимодействие с фильтрами

С фильтрами мы сталкивались уже не единожды, но так и не разобрали их подробно к этому моменту. Благо в текущей 
статье это не критично, а API для работы с фильтрами (но не API самих классов-фильтров) в принципе достаточно похоже 
на API для работы с сервлетами.

Так, `ServletContext` предоставляет для фильтров методы, по назначению идентичные методам сервлетов - создание, 
добавление, получение информации: `addFilter()`, `createFilter()`, `getFilterRegistrations()`,
`getFilterRegistration()`. Разве что вместо `ServletRegistration` соответствующие методы возвращают 
`FilterRegistration`. Что никак не меняет общий принцип работы.

#### Взаимодействие со слушателями

Логично продолжить следующей крупной составляющей сервлетных приложений - слушателями событий, с которыми более 
подробно познакомимся в следующем пункте.

Как и для сервлетов, `ServletContext` дает возможность создать объекты слушателей и добавить их в контекст: 
`addListener()`, `createListener()`. Но информацию о зарегистрированных слушателях получить не удастся. Вероятно, в 
силу того, что для них не требуется дополнительная конфигурация, указание маппингов и т.д.

#### Взаимодействие с атрибутами

Атрибуты - важный элемент сервлетных приложений. Именно через них можно реализовать инициализацию полей в сервлетах 
и фильтрах без создания лишних объектов и использования инструментов Java EE, ответственных за инверсию управления.
Также в атрибутах могут храниться различные конфигурации в виде конечных значений или объектов, агрегирующих эти 
значения. Иными словами, атрибуты - инструмент для использования через контекст всего того, что необходимо для работы 
приложения, но не укладывается в сервлеты, фильтры и слушатели.

Сами методы для работы с атрибутами максимально просты и отдаленно напоминают работу с `Map`:

1. `setAttribute(String name, Object object)`. Позволяет добавить атрибут, который в дальнейшем будет доступен по имени;
2. `getAttributeNames()`. Получение полного перечня имен атрибутов;
3. `getAttribute(String name)`. Получение атрибута по имени; 
4. `removeAttribute(String name)`. Удаление атрибута по имени.

#### Логирование

Также `ServletContext` предлагает возможность логирования "из коробки", без подключения знакомых нам SLF4J-логгеров. 
Сообщения логов будут добавляться в лог-файлы сервера. В реальной разработке такой подход нежелателен, но не 
отметить само API нельзя:

1. `log(String msg)`;
2. `log(String message, Throwable throwable)`.

Комментарии, полагаю, излишни. Отмечу лишь, что такого рода функциональность нетипична для контекстов - все же, их 
основная задача обычно заключается во взаимодействии с состоянием. 

#### Информационные методы

`ServletContext` предоставляет возможность получить большой перечень внутренней информации о приложении - путь 
самого приложения (часть между хостом и путем конкретного сервлета), версию приложения, информацию об адресе сервера 
и ряд других параметров.

#### Низкоуровневые методы

Далее, `ServletContext` позволяет взаимодействовать с файловой системой приложения - получить загрузчик классов 
(classloader) или же загрузить конкретный ресурс - файлы конфигурации, статические ресурсы, какие-либо внешние по 
отношению к приложению ресурсы. В целом, не рекомендую углубляться в это до тех пор, пока явно не потребуется в 
разрезе конкретной задачи.

#### Другое

Кроме рассмотренного выше существует еще масса методов `ServletContext`, описывать которые сложно. Мы еще банально 
не знакомы с механизмами, ради которых эти методы существуют.

Сюда относится API для работы с безопасностью и ролевой моделью приложения, API для JSP, сессий, управление кодировкой 
запросов и т.д.

Сюда же можно отнести добавление и получение параметров инициализации уровня приложения - тот же механизм, что и у
параметров инициализации в `ServletConfig`, но в привязке именно к контексту.

Хорошая новость в том, что обычно контексты более ограничены по своей зоне ответственности. В случае же с
`ServletContext` - это монструозная сущность, которой в сервлетном приложении подчинено практически все. 

## Паттерн наблюдатель. EventListener

Данный паттерн упоминался в статье, посвященной жизненному циклу сервлетного приложения. Как, впрочем, и 
`EventListener` с некоторыми имплементациями. Кроме того, в статье о `web.xml` также был и пример простейшего 
использования слушателей.

Данный же пункт нацелен на то, чтобы рассмотреть данный механизм через призму знакомства с контекстом. API 
конкретных слушателей примитивно и жестко привязано к триггеру, по которому они срабатывают. Вместо его разбора 
постараемся разобраться с самим паттерном и уложить его в модель работы контекста.

Основное, что необходимо понять - назначение слушателей. Они направлены на реализацию side-effect'ов - побочных 
действий, выполняемых при наступлении определенных событий. В данном случае "побочный" - не маркер второстепенности. 
Зачастую такие действия важны или даже критичны. Но они не связаны на прямую с событием, которое запустило их 
выполнение. 

Так, мы можем сделать слушатель, который при инициализации контекста будет создавать пул подключений к БД и/или 
запускать миграции. Эти действия определенно важны - без них приложение не сможет работать. Но они не имеют никакого 
отношения к контексту или его инициализации сами по себе.

Паттерн наблюдатель (observer) работает примерно следующим образом:

1. Есть основная сущность с определенным методом логики (далее - _МЛ_). Именно вызов данного метода и служит триггеров 
   для запуска слушателей. Сама логика вызова слушателей может находиться либо в самом _МЛ_, либо в методе, который его 
   вызывает. Последнее требует более строгих контрактов использования _МЛ_ - во избежание ситуации, когда метод 
   вызван, а слушатели не оповещены;
2. Существует общий интерфейс для слушателей (они же наблюдатели), определяющий API слушателя. Обычно это один метод 
   вроде `listen()` - название может быть любым. Также обычно, но не обязательно, в этот метод параметром передается 
   информация о случившемся событии. Формат передачи зависит от реализации;
3. Существуют механизмы "подписки" и "отписки" слушателей на событие. Лишь "подписанные" слушатели будут вызываться
   при наступлении события. В простой реализации - коллекция слушателей, в которую слушатель добавляется при 
   подписке (и удаляется при отписке);
4. При вызове _МЛ_ вызывается метод `listen()` или аналогичный ему у каждого подписанного слушателя. В простой 
   реализации - цикл проходит по коллекции слушателей и вызывает `listen()` у каждого.

В случае со слушателями в сервлетном приложении те же пункты выглядят примерно так:

1. _Основная сущность_. У нас МЛ много, под каждый свои слушатели. При этом большая часть МЛ скрыта от нас и находится 
   в коде контейнера сервлетов. К МЛ можно отнести метод инициализации контекста (недоступен), методы добавления и 
   удаления атрибутов контекста - скорее всего `ServletContext#setAttribute()` и `ServletContext#removeAttribute()` 
   и т.д.
2. _Слушатели_. Для нас такие интерфейсы - наследники `EventListener` в пакетах `jakarta.servlet` и 
   `jakarta.servlet.http`: `ServletContextListener`, `ServletContextAttributeListener` и т.д. Передача информации о 
   событии происходит через наследников `EventObject`, определенных в тех же пакетах, что и слушатели. Обычно они 
   содержат метод для получения контекста и, по необходимости, методы для доступа к запросу, атрибуту, сессии и т.д. -
   в зависимости от того, к какому событию привязан слушатель;
3. _Подписка_. Этот механизм находится на стороне контейнера сервлетов. Но он, вероятно, вызывается как при
   регистрации в контексте слушателей из `web.xml`, так и при регистрации слушателей, помеченных аннотацией 
   `@WebListener` и, конечно, при вызове `ServletContext#addListener()`. При этом сам механизм сложнее, чем в 
   описанной выше простой реализации - сначала нужно определить, на что должен триггериться слушатель, а лишь затем 
   "подписать" его. Кроме того, один и тот же объект слушателя иногда нужно подписывать к нескольким событиям - если 
   у него определено несколько методов (например, `contextInitialized()` и `contextDestroyed()` у
   `ServletContextListener`). Механизм "отписки", вероятно, не реализован;
4. Вызов слушателей при вызове МЛ тоже реализован на стороне контейнера сервлетов.

Таким образом, в данном случае мы видим верхушку айсберга - интерфейсы-контракты для определения собственных 
слушателей и несколько способов сообщить о существовании слушателей контексту. Оставшаяся и наиболее важная часть 
паттерна реализована внутри контейнера сервлетов. Мы можем посмотреть исходный код конкретных контейнеров и найти 
там имплементации именно этого механизма. Но в ситуациях, когда система работает в соответствии со спецификацией, в 
этом нет острой нужды.

#### С теорией на сегодня все!

![img.png](../../../commonmedia/defaultFooter.jpg)

Переходим к практике:

## Задача

Опишите сущность `Car` со свободным набором атрибутов (рекомендую базироваться на практике предыдущих уроков).
Реализуйте CRUD для нее, с соблюдением следующих условий:

1. Каждая из операций должна обрабатываться отдельным do-методом сервлета с маппингом `${contextPath}/car`. Для
   данных операций должны быть корректно определены методы HTTP с учетом семантики;
2. Тела запросов и ответов должны быть представлены в виде JSON;
3. Получение данных можно реализовать в любом из вариантов - по id, указанному фильтру или любым иным образом вплоть до
   получения всего списка машин без фильтрации;
4. Хранение данных должно быть реализовано на базе PostgreSQL;
5. Создание таблицы в БД должно быть реализовано с помощью миграций. Опционально могут быть добавлены индексы, в
   зависимости от используемого способа получения машин;
6. Классы бизнес-логики должны быть представлены синглтонами, их внедрение в сервлеты должно происходить с помощью
   функциональности слушателей.

Для тестирования работы приложения рекомендую использовать HTTP-клиент.

Ветка для PR: [for-pr](https://github.com/KFalcon2022/car-servlet-practical-task/tree/for-pr/context-and-listeners).

**Разбор практики для этого урока**:
[ссылка](https://github.com/KFalcon2022/car-servlet-practical-task/tree/solution/context-and-listeners)

> Если что-то непонятно или не получается – welcome в комменты к посту или в лс:)
>
> Канал: https://t.me/ViamSupervadetVadens
>
> Мой тг: https://t.me/ironicMotherfucker
>
> **Дорогу осилит идущий!**
