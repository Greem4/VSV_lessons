# Примеры работы с EntityManager и перспективы развития

Данная статья раскрывает некоторые сценарии использования `EntityManagerFactory` и `EntityManager`, демонстрируя 
способы эффективного взаимодействия с этими интерфейсами.

Также рассмотрены обходные пути для некоторых типовых проблем и описан подход, решающий эти проблемы в современной 
разработке.

## Примеры

Ключевая составляющая `EntityManager` - это API для взаимодействия с жизненным циклом сущностей. Остальные методы не 
менее полезны, но их использование более очевидно и не является чем-то характерным именно для JPA или ORM. 
Соответственно, этот пункт в первую очередь сконцентрируется на манипуляциях сущностями и тем, как их воспринимает 
JPA в различных ситуациях.

В дальнейшем мы будем рассматривать и другие, более сложные примеры взаимодействия с тем же API - например, в части 
работы со связанными сущностями. А сегодня сконцентрируемся на том, для чего хватает уже изученного материала.

> Для большей наглядности вы можете выполнить код, предложенный в примерах локально. И даже посмотреть, какие 
> SQL-запросы будут де-факто отправляться в БД на различных операциях с EM.
> 
> Для этого необходимо расширить конфигурацию `pesistence.xml`:
> 
> ```xml
> <persistence ...>
>     <persistence-unit ...">
>         ...
>         <properties>
>             ...
>             <property name="show_sql" value="true"/>
>         </properties>
>     </persistence-unit>
> </persistence>
> ```
> 
> А также в конфигурации логгера указать используемый уровень логирования для определенного логгера. В данном случае 
> (пример для log2j):
> ```properties
> log4j.logger.org.hibernate.SQL=DEBUG
> ```
> 
> Убедитесь, что общий уровень логирования стоит не ниже `DEBUG`:
> 
> ```properties
> rootLogger.level=DEBUG
> ```

### Помещение сущности под управление EM

Достаточно простой пункт, достижимый несколькими способами, в зависимости от обрабатываемой ситуации.

**Пример 1**. Создание новой сущности.

> Здесь и ниже для лаконичности опущен код создания объекта `EntityManagerFactory`. Соответствующая переменная 
> используется под названием `emf`.  

Именно такой вариант мы уже рассматривали в предыдущих статьях, но теперь рассмотрим уже осознанно:

```java
try (EntityManager em = emf.createEntityManager()) {
    var transaction = em.getTransaction();
    transaction.begin();

    var person = new PersonEntity();

    person.setName("Иван");
    person.setAge(34);
    person.setGender(GenderType.MALE);
    person.setFavoriteColors(List.of("Красный", "Черный"));

    em.persist(person);
    transaction.commit();
}
```

Посредством дебаггера легко заметить, что после выполнения `em.persist(person)` у объекта `person` заполняется 
идентификатор. При этом фактически выполняемые запросы к БД на этом этапе могут быть различны или отсутствовать 
вовсе - в зависимости от выбранной в `@GeneratedValue` стратегии.

Так, для `IDENTITY` будет произведена фактическая вставка сущности в БД - именно на этом этапе ей будет присвоен
идентификатор. Для `SEQUENCE` - будет лишь вызван запрос на получение следующего значения последовательности. Для 
`UUID`* запросов не будет вовсе - он генерируется в пределах Java-приложения.

> *Чтобы убедиться на практике, потребуется изменить тип поля `id`. И связанной колонки в БД. 

Далее вызывается коммит транзакции. Перед ним автоматически происходит синхронизация EM с базой данных. В 
зависимости от стратегии `@GeneratedValue` произойдет вставка сущности (если не произведена ранее) или не будет 
выполнено никаких дополнительных запросов.

Пример выше наиболее простой. В реальных задачах никто не запрещает создавать в пределах работы одного EM множество 
сущностей, не ограничено их изменение после вызова `persist()` и т.д. До тех пор, пока ваши действия не нарушают 
ограничений JPA - EM берет на себя ответственность за синхронизацию состояний сущностей и БД. Исключения есть, но 
они характерны для не самых типичных сценариев использования.

**Пример 2**. Обновление сущности.

В большинстве ситуаций, когда сущность не создается, она попадает под контроль EM через получение из базы данных.

В предыдущей статье мы уже разбирали примеры использования EM для выполнения нативных запросов к БД, здесь же 
разберем еще более простой, но при этом очень востребованный на практике способ - получение по идентификатору.

В классическом CRUD этот способ очень распространен - сущности обновляют по идентификатору, получают по 
идентификатору (как правило, полученному от иных сущностей), удаляют по идентификатору:

```java
try (EntityManager em = emf.createEntityManager()) {
    var transaction = em.getTransaction();
    transaction.begin();

    var person = em.find(PersonEntity.class, 1L);

    person.setName("Петр");
    person.setAge(22);
    person.setGender(GenderType.UNDEFINED);

    transaction.commit();
}
```

EM делает запрос в БД, помещает полученную сущность под свое управление и возвращает из метода `find()`. После этого 
любые изменения сущности будут учитываться и, в конечном итоге, будут применены в БД при успешном коммите транзакции.

При чем стоит понимать, что не все действия с EM требуют открытой транзакции. Фактически, из управляющих методов 
жесткое требование по наличию активной транзакции имеют только `flush()`, `lock()` и `joinTransaction()`. При чем 
для двух последних это требование очевидно - механизмы, которые они запускают, напрямую связаны с транзакцией в БД 
или в JPA. Для `flush()` это требование скорее следует из контракта, нежели обусловлено объективно необходимостью - 
синхронизация изменений с БД вне транзакции может нарушить ACID.

Таким образом, если ваша задача состоит лишь в получении сущностей без их изменения в БД - транзакцию можно не 
открывать вообще.

Но если при работе с данным EM вы планируете изменять состояние сущностей - лучше открыть транзакцию еще до получения
изменяемой сущности. С одной стороны, это увеличит время фактического существования транзакции, с другой - улучшит
читаемость кода в сравнении с более поздним открытием в месте, где транзакция покажется вам необходимой. Это же может
защитить вас от некоторых неочевидных ситуаций, когда EM синхронизируется в БД неявно. Более тонкие манипуляции и 
оптимизации возможны, но требуют четкого осознания, зачем они производятся в каждом конкретном случае.

### Обновление сущности через merge()

Предыдущий пример обновления сущности - классический для JPA: получили из БД, обновили в Java-коде, синхронизировали 
с БД.

Альтернативный вариант позволяет не получать сущность из БД*. Наиболее простой и распространенный пример - нам 
необходимо обработать HTTP-запрос, в котором пользователь (приложение-клиент) прислал id обновляемой сущности и 
полный состав атрибутов сущности со желаемыми значениями. Задача сводится к валидации значений и сохранении в БД. 

В таком виде выглядит, будто нет никакой необходимости получать сущность из базы данных, чтобы ее обновить. Достаточно 
создать объект, поместить его под контроль JPA и сохранить.

Проблема заключается в том, что в созданном entity-объекте нам потребуется установить значение id. И если после этого 
мы вызовем `persist()`, а для entity определены правила автоматического присвоения id - произойдет ошибка: id уже 
задан и JPA считает такое поведение недопустимым.

Иными словами, мы не можем использовать `persist()`, чтобы поместить под контроль EM сущность, уже существующую в 
БД. Такая сущность, не находясь под управлением EM, рассматривается как `Detached`. А для таких случаев определен 
метод `merge()`. Который мы и будем использовать.

> На самом деле, если мы используем Hibernate, запрос сущности из БД все равно произойдет. JPA не требует этого в 
> явном виде, но Hibernate проверяет, существует ли запись с указанным в БД. Также есть и другие механизмы, для 
> которых Hibernate может использовать полученную запись, но сейчас они не имеют значения.
> 
> Для других реализаций JPA запроса действительно может не осуществляться - в зависимости от их внутренней реализации.

Выглядеть это может примерно так:

```java
try (EntityManager em = emf.createEntityManager()) {
    var transaction = em.getTransaction();
    transaction.begin();

    var person = new PersonEntity();

    person.setId(1L);
    person.setName("Петр");
    person.setAge(22);
    person.setGender(GenderType.UNDEFINED);

    em.merge(person);

    transaction.commit();
}
```

Стоит отметить, что этот подход нереализуем, если у сущности есть поля, которые должны изменяться строго относительно
своего предыдущего значения и при этом не передаются извне. В таком случае мы не сможем вычислить их корректные
значения. Но это достаточно редкие ситуации.

Второй важный момент - этот подход более требователен к корректному описанию метамодели сущности.

Например, в `PersonEntity` есть поле `created`, которое заполняется JPA перед вызовом `persist()` (базируясь на методе, 
аннотированном `@PrePersist`). И здесь возникает проблема: колонка `created` в БД помечена как `NOT NULL`, но мы не 
можем узнать значение без запроса в БД. Если же принимать это значение извне (например, от клиентского приложения, 
которое пытается обновить сущность в нашей БД) - нет гарантий, что оно будет совпадать с реальным. То есть 
единственный доверенный источник значения - БД, а не заполнить поле нельзя.

Дилемма решается, если мы сообщаем метамодели больше деталей. Скажем, указываем в аннотации `@Column` над `created`, 
что поле не обновляемо - `updatable = false`. В таком случае JPA исключит данное поле из UPDATE-запроса и оно не 
будет изменяться в принципе.

В завершение остается добавить, что хоть такой вариант и возможен, он редко используется на практике - SELECT-запрос 
с поиском по id является относительно недорогой операцией, при этом он дает больше гибкости в работе с обновляемым 
объектом. Но обойти реализацию с `merge()` стороной мы не могли - это один из немногих примеров использования 
данного метода, актуальных для нас на текущий момент. Остальные ситуации более специфичны.

### Удаление сущности

Удаление записи из БД - задача достаточно тривиальная. Но, как и в случае с обновлением, в подходе по умолчанию нам 
потребуется сначала извлечь сущность из базы - `EntityManager#remove()` ожидает параметром entity-объект, 
находящийся под управлением EM.

**Пример 1**. Получение из БД и удаление:

```java
try (EntityManager em = emf.createEntityManager()) {
            var transaction = em.getTransaction();
            transaction.begin();

            var person = em.find(PersonEntity.class, 1L);

            em.remove(person);

            transaction.commit();
        }
```

**Пример 2**. Удаление без явного получения из БД:

```java
try (EntityManager em = emf.createEntityManager()) {
    var transaction = em.getTransaction();
    transaction.begin();

    var person = new PersonEntity();
    person.setId(1L);

    var mergedPerson = em.merge(person);
    em.remove(mergedPerson);

    transaction.commit();
}
```

Это второй пример с использованием `merge()`, доступный нам на данный момент. Единственный момент, который стоит 
держать в голове - `merge()` всегда создает копию detached-сущности. И уже копию помещает под управление EM. Если 
для обновления это было не критично - мы указали в объекте все нужные изменения еще до вызова `merge()`, то здесь 
явно необходимо использовать managed-сущность. Что и выражено в коде.

### Выведение сущности из-под контроля EM

Данный пункт достаточно специфичен и нужен редко. Еще реже он нужен в прикладном коде, а не для чисто технических задач.

Наиболее понятным, на мой взгляд, примером использования могут быть кэши.

Допустим, я знаю, что моя сущность обновляется редко или не обновляется вообще в силу своей роли в системе. Но при 
этом ее часто запрашивают из БД. В таком случае кажется логичным сохранить ее в какой-то кэш - в наивной 
реализации это может быть даже `Map` внутри Java-приложения. Получается, мне необходимо получить сущность через EM, 
поместить в кэш и в дальнейшем предоставлять ее уже из кэша, не обращаясь в БД.

Проблема в том, что если я это сделаю в лоб - возможны различные сайд-эффекты, связанные с тем, что сущность все еще 
находится под контролем EM. И чтобы этого избежать - ее логично из-под этого контроля вывести.

> Откровенно говоря, пример выглядит натянутым в текущем описании. Сама ситуация имеет право на жизнь, но на данном
> этапе мы еще не изучили материал, который позволил бы более четко объяснить актуальность описываемого подхода.
> 
> В любом случае, вероятность того, что вам придется использовать этот метод на практике, стремится к нулю.

```java
private final Map<Long, PersonEntity> personCache = new ConcurrentHashMap<>();

public PersonEntity getById(Long id) {
    var person = personCache.get(id);
    
    if (person != null) {
        return person;
    }

    try (EntityManager em = emf.createEntityManager()) {
        person = em.find(PersonEntity.class, id);
        personCache.put(id, person);
        
        return person;
    }
}
```

### Синхронизация EM и БД

Несмотря на то, что JPA всеми силами отваживает разработчика от непосредственной коммуникации с БД, бывают ситуации, 
в которых необходимо явно указать, что сущность EM должен сообщить БД текущее состояние подконтрольных объектов или 
наоборот - определенная подконтрольная сущность должна быть приведена к состоянию, актуальному в БД. Иными словами, 
иногда необходимо учитывать несовершенство виртуальной объектной БД.

Чаще всего такие ситуации возникают или при работе со связанными сущностями, или при нестандартных настройках 
`flushMode`.

Примеры ниже во многом утрированы, чтобы использовать лишь уже изученные нами возможности JPA, однако их суть 
остается актуальной и для реальных ситуаций.

**Пример 1**. Необходимо обновить состояние сущности в EM состоянием из БД.

```java
try (EntityManager em = emf.createEntityManager()) {
    var transaction = em.getTransaction();
    transaction.begin();

//    Получаем сущность из БД    
    var person = em.find(PersonEntity.class, 1L);

//    В силу бизнес-логики полученная сущность обновляется в БД, EM хранит устаревшее значение
    em.createNativeQuery("update person set age = age + 1")
                    .executeUpdate();

//    Обновляем значение сущности на базе БД 
    em.refresh(person);

    transaction.commit();
}
```

Проблема, возникающая выше, связана с тем, что JPA фактически не имеет инструментов для отслеживания изменений, 
внесенных модифицирующими нативными запросами. Как имеет и ряд других пробелов в покрытии ситуаций, когда изменение 
с БД происходило без явного фигурирования `id`. Не говоря о более неприятных ситуациях, когда обновление происходит, 
например, по триггеру - тогда не остается даже призрачной надежды, что JPA узнает об изменении автоматически.

Более распространенный на практике вариант происходит при обновлении связанных entity-объектов - к нему мы вернемся 
в одной из ближайших статей. 

**Пример 2**. Необходимо промежуточное обновление БД на базе содержимого EM.

Такой сценарий маловероятен при стандартной конфигурации EM - `flush()` неявно вызывается перед каждым запросом 
(нативным, JPQL или сгенерированным с помощью Criteria API), что фактически гарантирует согласованность между EM и 
БД (в разрезе текущей транзакции) в момент выполнения запроса.

Но если ради оптимизации или в силу иных причин мы вынуждены использовать `FlushModeType.COMMIT`, может возникнуть 
следующая ситуация:

```java
try (EntityManager em = emf.createEntityManager()) {
    em.setFlushMode(FlushModeType.COMMIT);
    var transaction = em.getTransaction();
    transaction.begin();

    var person = em.find(PersonEntity.class, 1L);

    person.setAge(133);

    // oldPersonsCount = 0
    var oldPersonsCount = em.createNativeQuery(
                    "select count(*) from person where age > 100",
                    Long.class)
            .getSingleResult();

    transaction.commit();
}
```

Решение очевидно:

```java
try (EntityManager em = emf.createEntityManager()) {
    em.setFlushMode(FlushModeType.COMMIT);
    var transaction = em.getTransaction();
    transaction.begin();

    var person = em.find(PersonEntity.class, 1L);

    person.setAge(133);

    em.flush();

    // oldPersonsCount = 1
    var oldPersonsCount = em.createNativeQuery(
                    "select count(*) from person where age > 100",
                    Long.class)
            .getSingleResult();

    transaction.commit();
}
```

Опять же, при реальном использовании необходимость принудительного обновления БД бывает не так очевидна - 
транзакция может быть разбросана по нескольким методам, в результате чего затрудняется отслеживание описанной проблемы.

### Разделение транзакции между несколькими методами

Этот пункт останется без примеров в виде кода - во-первых, на текущем этапе они будут не показательны, во-вторых,
в них нет острой необходимости - проблему легко представить и без него.

Вполне вероятны ситуации, когда в пределах одной бизнес-операции должны обновляться различные сущности - в том числе 
различные таблицы. При этом отдельные части данной бизнес-операции могут быть актуальны и в других операциях. Таким 
образом вполне ожидаемо, что код окажется разбросан по разным методам и, вероятно, разным классам.

Проблема заключается в том, что часто такие операция требуют атомарного выполнения - то есть все изменения должны 
либо примениться в полном объеме, либо не примениться вовсе. Из чего следует необходимость производить эти изменения 
в одной транзакции и, в случае с JPA, с помощью одного объекта EM.

Ниже будет описано, как эта проблема решается в современной разработке. На нашем текущем уровне наиболее простым 
решением будет передача объекта `EntityManager` через параметры метода. И реализация соответствующей перегрузки для 
методов, который могут как использоваться самостоятельно, так и вызываться из другого метода, использующего EM.

Хорошая новость в том, что в отличие от JDBC, где нам похожим образом уже приходилось передавать объект `Connection`,
JPA зарекомендовала себя как концепция, работающая на уровне бизнес-логики*. То есть при использовании JPA без более 
высокоуровневых настроек вполне корректно и ожидаемо использование `EntityManager` и иных интерфейсов в классах 
логики.

Более того, в классическом для JPA сценарии вообще исчезает необходимость в отдельном архитектурном слое для 
коммуникации с БД. По крайней мере, теоретически. На практике все равно никуда не деться от сложных и многократно 
переиспользуемых в различных частях системы запросов, независимо от того, с использованием какого API они были 
написаны. Но именно взаимодействие с Entity и их жизненным циклом действительно становится достоянием слоя 
бизнес-логики.  

> *Фактически, не столько зарекомендовала, сколько не было альтернативы - так или иначе нужно передавать 
> ассоциированный с транзакцией объект между классами логики, вынося его выше слоя непосредственной коммуникации с 
> БД. Эта проблема актуальна при любой попытке гарантировать атомарность выполнения за счет транзакции БД. 

### Шаблонный код

Проблема JPA в той конфигурации, которую мы используем - шаблонный код для создания EM, открытия и фиксации 
транзакций, закрытия EM.

Одним из вариантов решения может стать нечто аналогичное `TransactionTemplate`, который был представлен в разборе 
практики для JDBC. Который будет хранить в поле объект EMF и предоставлять метод, принимающий лямбда-выражение:

```java
public class EntityManagerHelper {
    private final EntityManagerFactory entityManagerFactory;

    public <T> T runTransactional(Function<EntityManager, T> function) {
        try (var em = entityManagerFactory.createEntityManager()) {
            try {
                var transaction = em.getTransaction();
                transaction.begin();

                T result = function.apply(em);

                transaction.commit();

                return result;
            } catch (Exception e) {
                em.getTransaction().rollback();
                throw e;
            }

        } catch (Exception e) {
            if (e instanceof RuntimeException runtimeException) {
                throw runtimeException;
            }

            throw new RuntimeException("Ошибка при обработке транзакции", e);
        }
    }

    // ... - Конструктор и другие необходимые методы 
}
```

В таком виде он не подойдет для ситуаций, когда требуется нестандартная конфигурация `EntityManager`. Но это можно 
исправить, добавив перегрузку с дополнительным набором параметров.

Также такой подход может оказаться не слишком удачный, если внутри лямбда-выражения есть работа с транзакцией -
например, ее откат в рамках какой-то внутренней бизнес-логики. В таком случае текущее решение будет завершаться с 
ошибкой при попытке вызвать `EntityTransaction#commit()`. Но и это может быть доработано через добавление проверки 
на активную транзакцию. Либо же в пределах контракта работы с `runTransactional()` можно требовать использовать 
только `setRollbackOnly()` для указания на необходимость откатить изменения. Но это требование не всегда выполнимо и 
его проблематично контролировать без создания дополнительных классов-декораторов для `EntityManager` и
`EntityTransaction`.

Наконец, предложенное решение не облегчает ситуаций, когда одна транзакция охватывает несколько Java-методов. К 
сожалению, для таких ситуаций все еще придется передавать объект EM через параметры метода.

### Работа с EntityManagerFactory в сервлетных приложениях

Большинство приложений работают лишь с одним объектом EMF - одна БД с одним сценарием подключения. Какой-либо 
необходимости пересоздавать EMF в процессе жизни приложения обычно нет, что по итогу приводит к логичной мысли 
управлять созданием и закрытием EMF через `ServletContextListener`:

```java
public class JpaAttributeContextListener implements ServletContextListener {
    private static final String EMF_ATTRIBUTE_NAME = "entityManagerFactory";
    private static final String PERSISTENCE_UNIT_NAME = "Hibernate";

    @Override
    public void contextInitialized(ServletContextEvent event) {
        var emf = Persistence.createEntityManagerFactory(PERSISTENCE_UNIT_NAME);
        servletContext.setAttribute(EMF_ATTRIBUTE_NAME, emf);
    }

    @Override
    public void contextDestroyed(ServletContextEvent event) {
        var servletContext = event.getServletContext();
        
        var emf = (EntityManagerFactory) servletContext.getAttribute(EMF_ATTRIBUTE_NAME);
        emf.close;
    }
```

Остается только передавать добавленный атрибут в объекты, которым для работы потребуется `EntityManager` - как правило,
в классы-сервисы и репозитории.

Если в приложении определена коммуникация с несколькими БД через JPA или по иным причинам необходимо несколько EMF - 
логика не меняется, как правило, EMF создается на старте приложения и закрывается при завершении. Останется только 
определить корректные имена для атрибутов.

> На самом деле прикладная ценность двух последних пунктов невелика - абсолютное большинство реальных проектов 
> используют более оптимальные способы взаимодействия с EMF и EM. Ниже об этом рассказано чуть подробнее.
> 
> Примеры выше преследуют две цели:
> 
> - Облегчить выполнение практических задач в разделе JPA;
> - Продемонстрировать, что зачастую даже объективные ограничения фреймворков и библиотек могут быть можно дешево 
>   обойти. Более того, если вы чувствуете, что какое-то взаимодействие с популярным фреймворком доставляет 
>   неудобства - с большой долей вероятности кто-то уже решил проблему до вас, достаточно поискать. И лишь в 
>   случае отсутствия адекватных альтернатив приступать к изобретению велосипеда.   

## Перспективы

Как было сказано выше, ручное создание EM - достаточно неудобная штука. Еще больше неудобств доставляют ситуации, когда 
транзакция (читай, действие EM) распространяется на несколько методов и приходится передавать между методами сам объект
EM.

В конце концов, такой подход к объединению работы нескольких методов в одну транзакцию мы можем реализовать и с 
`Connection` в JDBC.

Данную проблему в разных технологических стеках решают по-разному. Но для схожих ситуаций все сводится примерно к 
одному принципу. Поскольку транзакция обычно должна распространятся в пределах одного потока (на иное JPA и не 
рассчитан), все сводится к тому, чтобы так или иначе связать поток выполнения с транзакцией (в данном случае - с 
`EntityManager`). Все что останется - отслеживать, когда транзакция открывается и закрывается, для чего вводится 
некая сущность, отвечающая за это.

Концептуально проблема решена - остается лишь как-то сообщать описанному механизму, что нам нужен объект EM и что 
транзакцию необходимо открыть или зафиксировать. Если мы попробуем понять, как это устроено в Spring-экосистеме и в 
Java/Jakarta EE приложениях - детали будут отличаться. Отличия будут даже внутри одного из выбранных стеков, в 
зависимости от версии и используемых модулей. Но некий обобщенный вариант можно описать так:

Объект EM может быть получен как поле класса через аннотацию `@PersistenceContext` - эта аннотация определена в JPA, 
но в Java SE сама по себе не работает.

Управление началом и завершением транзакции можно реализовать декларативно - через установку аннотации над методом. 
Уже на этом этапе пропадает необходимость передавать объект EM между методами - если управляющая сущность видит 
аннотацию, она будет искать активный EM для текущего потока* (для ситуаций, когда аннотированный метод был вызван из 
другого аннотированного метода). Если найдет - будет использовать, если нет - создаст новый EM. И в Spring, и в 
Jakarta EE для описанных целей существует аннотация `@Transactional`. У них различаются конфигурации, но решаемые 
задачи идентичны.

> *И конкретно здесь, и вообще в этом пункте (и, откровенно говоря, достаточно часто в курсе) я опускаю многие детали и 
> специфику конфигураций, описывая наиболее простой и понятный на данный момент сценарий использования.
> 
> При знакомстве со Spring Framework мы изучим описанный выше механизм более детально, рассмотрев, как это работает 
> и как может быть сконфигурировано под различные задачи.  

Итого, при более продвинутом использовании JPA получается примерно следующее:

- Получение объекта EM происходит декларативно через аннотацию `@PersistenceContext`;
- Объект EM связывается с потоком выполнения, создавая некий транзакционный контекст выполнения, что избавляет от 
  необходимости явно передавать EM между методами;
- Точки открытия и фиксации транзакций (области жизни EM) могут задаваться декларативно через аннотацию 
  `@Transactional` - открытие будет привязано к началу обработки аннотированного метода, а фиксацию - к завершению. 
  Если один аннотированный `@Transactional` метод будет вызывать другой аннотированный метод - будет использоваться 
  существующий для потока EM;
- Для обеспечения описанного механизма должна существовать контролирующая сущность, которая будет связывать 
  создавать (и закрывать) объект EM для потока по мере необходимости, обрабатывать необходимость предоставления 
  объекта EM и обеспечивать ряд других вспомогательных функций.

> Для тех, кто хочет погрузиться в данную тему подробнее самостоятельно.
> 
> Для Spring Framework стоит искать информацию о модулях Spring Data JPA и Spring-tx. Для Jakarta EE - EJB и JTA.
> 
> Но в обоих случаях так или иначе придется разбираться с концепцией **инверсии управления** и модулями каждой из 
> экосистем, которые ее обеспечивают. Поэтому если вы еще не знакомы со Spring (или Jakarta CDI для JEE) - 
> рекомендую пока отложить.

#### На сегодня все!

![img.png](../../../commonmedia/justTheoryFooter.png)

> Если что-то непонятно или не получается – welcome в комменты к посту или в лс:)
>
> Канал: https://t.me/ViamSupervadetVadens
>
> Мой тг: https://t.me/ironicMotherfucker
>
> **Дорогу осилит идущий!**
