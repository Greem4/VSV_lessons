# ORM и JPA. Что такое Hibernate

С этой статьи начинается раздел, посвященный одному из наиболее популярных подходов в работе с реляционными БД в 
Java - JPA. Текущая статья представляет собой вводный теоретический материал, призванный рассказать о теоретических 
основах API, с которыми мы будем знакомиться в ближайших статьях.

Сегодня мы познакомимся с концепцией **ORM** и основанной на ней спецификацией в Java EE - **JPA**. А также начнем 
разбор наиболее популярной реализации данной спецификации - Hibernate.

## ORM

ORM (Object-Relational Mapping) - подход в объектно-ориентированных языках программирования, направленный на 
взаимодействие с реляционными базами данных через специальные абстракции, которые минимизируют прямую коммуникацию с 
БД через написание SQL-запросов. Вместо этого ORM предоставляют различные интерфейсы, моделирующие "виртуальную 
объектную базу данных". Это позволяет работать с таблицами, записями и связями в объектно-ориентированной парадигме.

Подобное определение достаточно сложное для восприятия, поскольку описывает достаточно обобщенный подход, имеющий 
массу различных имплементаций в различных языках программирования. По ходу знакомства с ORM и ее имплементацией в 
Java сама концепция и ее общее описание станут понятнее.

Общая идея ORM заключается в том, что реляционная модель данных слишком плохо ложится на ООП, из-за чего в Java и 
иных объектно-ориентированных языках работа с базой данных реализована неудобно для разработчиков.

Рассматривая, например, JDBC, можно выделить следующие проблемы.

### Различие подходов работы с данными 

Объектно-ориентированные языки и реляционные БД предоставляют разные подходы для работы с данными.

Первые предоставляют возможность создавать сложную структуру объектов, включая иерархии (через наследование) и 
иные связи между объектами одно или разных типов (через композицию и агрегацию). Сюда же можно отнести инкапсуляцию 
и полиморфизм, которые позволяют весьма гибко контролировать доступность объектов и правила их изменения.

Вторые же оперируют таблицами, записями в них (строками) и отношениями между ними. При этом практически отсутствуют 
механизмы, которые позволяют гибко настраивать доступность и правила взаимодействия со строками таблиц - в 
классическом представлении реляционной БД не нужны эти механизмы, потому что это не ее зона ответственности.

Тем не менее концепции похожи, особенно, если исключить наследование. Таблицы и строки явно ассоциируются с классами 
и объектами, связи в таблицах - со связями между объектами и т.д. Но в прикладных задачах, даже типовых, часто 
всплывают серьезные различия в подходах - жизненные циклы и срок жизни связанных объектов и их представлений в БД, 
правила изменения объектов и ассоциированных с ними строк, иные особенности создания, обновления и удаления объектов в
системе. За пределами наиболее простых случаев разница в объектно-ориентированной и реляционной парадигмах становится
заметна и приводит к сложностям в разработке и поддержке.

### Ручное управление запросами

Для работы с реляционными базами данных необходимо оперировать SQL-запросами. Это кажется логичным.

Но фактически это выливается в большое количество типового кода и затраты на поддержку актуальности запросов: ручное 
получение объекта `Connection`, императивная работа с параметрами запроса в `PreparedStatement` и `ResultSet` для 
конвертации данных между Java-объектом и SQL.

Наконец, любое изменение состава полей объекта и колонок базы данных требует согласования как на уровне структуры
класса и таблицы (об этом чуть позже), так и на уровне запроса. Банальное добавление нового поля в класс может
потребовать изменения десятков запросов к БД, чтобы это поле не было утеряно при вставке, обновлении или чтении данных.

При этом практически весь подобный код является типовым и однообразным, а его количество неминуемо приводит к 
ошибкам при развитии системы. Во многом в связи с человеческим фактором.

### Работа со связями

Как уже было сказано выше, реляционные БД поддерживают связи между таблицами через механизм Foreign Key.

Но разница в представлении никуда не исчезает - там, где в объектно-ориентированном представлении поле объекта 
содержит прямую ссылку на другой объект (o2o, m2o) или коллекцию объектов (o2m, m2m), в БД остается оперировать FK и 
промежуточными таблицами (для m2m), а доступ к связанным сущностям обеспечивать через `JOIN` или дополнительные запросы.

Таким образом достаточно очевидная задача получения из БД конкретного объекта с его связями может превратиться в 
объемное решение с множеством простых запросов или одним сложным. И последующим маппингом полученных данных в их 
объектные представления.

То же самое будет наблюдаться и для добавления новой связанной сущности - особенно для m2m и o2m связей. На уровне 
Java-кода разработчик будет оперировать коллекцией, но каждый новый элемент этой коллекции должен быть вручную 
добавлен в соответствующую ему таблицу в БД. Еще больше ситуация усложнится для транзакционных изменений, но об этом -
в следующем пункте.  

### Транзакции

Этот пункт отчасти аккумулирует в себе сказанное ранее.

Единицей работы с реляционной БД обычно считают транзакцию. Это, в целом, удобная концепция - атомарность даже для 
множества изменений, согласованность данных после фиксации транзакции и т.д.

Это же хорошо перекликается с программной частью продукта - выполнение одной пользовательской операции чаще всего 
требует и атомарности, согласованности и устойчивости (A, C, и D в ACID). Изолированность не менее важна, но 
куда менее очевидна для бизнеса.

Т.е. делая какое-то действие в системе пользователь вполне обоснованно считает, что действие должно выполниться
полностью или же ничего измениться не должно (в случае ошибки), все данные должны после завершения операции остаться 
корректными или не измениться вообще (в случае ошибки) и никакие последующие проблемы не должны отразиться на уже
выполненной операции.

Что характерно, пользователя совершенно не волнует, сколько объектов будет затронуто во время обработки операции, 
каким образом они будут изменены и сохранены. И это тоже вполне обоснованно.

Зато разработчика история с изменением объектов и обеспечением ACID волнует в полной мере. И мы вполне может 
представить ситуацию, когда одна бизнес-операция требует выполнения множества запросов, ее логика может быть 
разбросана по разным методам и классам и т.д. Такую ситуацию можно было наблюдать даже в некоторых практических 
заданиях раздела "JDBC".

И в случае работы через JDBC это фактически заставляет разработчика смешивать бизнес-логику с логикой работы с БД. 
Потому что обеспечить выполнение ACID в описанной ситуации можно только посредством транзакции в БД. А транзакция 
жестко связана с `Connection` в JDBC. Т.е. для того, чтобы все методы, необходимые для выполнения бизнес-операции 
работали с БД в пределах одной транзакции, необходимо, чтобы все эти методы работали с БД через один и тот же 
`Connection`. А значит надо как-то передавать именно этот `Connection` во все эти методы.

Достаточно карикатурно описанная проблема продемонстрирована здесь:
[ссылка](https://github.com/KFalcon2022/jdbc-practical-tasks/blob/solution/src/main/java/com/walking/jdbc/service/TicketService.java),
метод `TicketService#create()`. Даже простая операция потребовала оперировать сущностями JDBC на уровне сервиса. А 
ведь многие бизнес-операции затрагивают сразу несколько классов бизнес-логики. Т.е. даже приведенный пример 
достаточно оптимистичен - по крайней мере, в нем все инкапсулировано в пределах одного сервиса и удалось обойтись 
без передачи объекта `Connection` в другие классы бизнес-логики.  

Вероятно, именно описанная ситуация и другие проблемы в работе с транзакциями - основная причина появления ORM. По 
крайней мере, именно в этом направлении подумает большинство разработчиков в первую очередь, если вы попросите 
рассказать про преимущества ORM. 

### Кэширование

Данный пункт также связан, в первую очередь, с работой в пределах транзакций, хоть и не ограничивается ими.

Если для упрощения считать, что одна бизнес-операция ассоциируется с одной транзакцией, вполне распространена 
ситуация, когда к одной сущности (записи в БД) будет происходить несколько обращений в разных частях логики. При 
этом возможен как read-only доступ, так и множественное изменение этой сущности.

В традиционном для SQL (и, часто, JDBC) подходе, каждый раз обращение к сущности будет происходить через отдельный 
SQL-запрос - например, через поиск по PK (id). Также и каждое изменение сущности будет сопряжено с отдельным 
UPDATE-запросом. А ведь сущностей, затрагиваемых в пределах бизнес-операции, может быть множество. И для каждой из 
них возможно выполнение множественных запросов на получение и обновление.

При этом получается, что каждый раз приложение вынуждено обращаться в БД для получения или обновления одних и тех же 
записей, увеличивая общее количество блокирующих операций. Но если единицей работы с БД мы считаем транзакцию - 
фактически, всю массу этих обращений мы совершаем в пределах одной атомарной операции.

Получается, будто нам не хватает какого-то механизма кэширования, который позволит хотя бы в пределах одной 
транзакции работать с сущностью без постоянных обращений в БД. В зависимости от уровня изоляции транзакции это может 
иметь разные последствия, но концептуальное преимущество в виде меньшего числа запросов к БД достаточно прозрачно.

### Несоответствие структур данных

Мы уже отметили, что любые изменения класса, ассоциируемого с определенной таблицей, может потребовать изменения 
множества запросов.

Но кроме этого существует и вопрос актуализации DDL в самой базе данных - для каждого добавленного в класс поля
требуется совершить запрос на добавление колонки в таблице, для измененного или удаленного поля - ALTER- или 
DROP-запрос для соответствующей колонки.

Соответственно, не хватает какого-то механизма, который автоматизировал бы этот процесс или хотя бы следил за 
соответствием класса таблице и наоборот.

> !NB: фактически в современной разработке, по крайней мере, в Java эта проблема не решается через ORM. И 
> используются инструменты для миграций, с которыми мы уже знакомы.
> 
> Но так как ORM эту проблему описывает, а реализации ORM предлагают инструменты для ее решения, не озвучить 
> данный тезис было бы некорректно.
> 
> Если же говорить о практике применения, то инструменты ORM для обеспечения соответствия таблицы и класса обычно 
> либо выключают полностью, либо оставляют в режиме валидации, при его наличии. По этой же причине в курсе не будут 
> рассмотрены данные инструменты в JPA и Hibernate.
> 
> Причин, по которым работа с DDL вынесена за пределы зоны ответственности ORM, достаточно много и их описание 
> будет объемным. Скорее всего, этот вопрос будет рассмотрен в качестве дополнительной статьи к разделу "JPA и 
> Hibernate".

### В заключение об ORM

Описанные выше проблемы стали причиной появления ORM. Различные имплементации ORM используют разные (на зачастую 
схожие) подходы к их решению. Как пытаясь решить сразу все, так и концентрируясь лишь на части из них, в зависимости 
от реализации.

Дальше мы будем рассматривать ORM и, соответственно, решения описанных проблем, в парадигме JPA. Соответственно,
не все сказанное будет справедливо для ORM в общем случае. И при изучении другого ЯП или другой реализации ORM для 
Java, вам придется вновь вернуться к теме ORM и посмотреть на нее под иным углом.   

## JPA

JPA - Java Persistence API, оно же Jakarta Persistence API - спецификация Java EE, которая реализует концепцию ORM.

JPA представляет собственные интерфейсы и механизмы, которые в том или ином виде решают все описанные выше проблемы. 
С конкретными инструментами мы будем знакомиться в следующих статьях, пока постараемся тезисно определить, что нам 
предоставляет эта спецификация.

### Основные разделы

Среди ключевых тем при знакомстве с JPA можно выделить следующие:

- Публичное API. Основные интерфейсы и аннотации для работы с JPA. Именно ему будет посвящена большая часть текущего 
  раздела. Расположено в пакете `javax.persistence` (в более новых версиях - `jakarta.persistence`);
- Criteria API. Механизм для построения сложных запросов в Java-коде. Хорошо подходит для запросов с гибкой 
  настройкой фильтров и других ситуаций, когда запрос необходимо строить динамически, в зависимости от входных 
  данных. Интересный, но не самый популярный инструмент в силу ряда причин. Подробнее разберемся в соответствующей 
  статье. Расположен в пакете `javax.persistence.criteria` (`jakarta.persistence.criteria`);
- JPQL. Java Persistence Query Language. Специально разработанный SQL-подобный язык, который оперирует
  JPA-сущностями вместо таблиц. Это упрощает описание некоторых операций вроде простых JOIN'ов, но вместе с этим 
  накладывает и ряд ограничений. Знакомство с данной технологией также вынесено в отдельную статью;
- Автоматическая генерация и валидация DDL. Этот подход позволяет не заботиться о миграциях, вместо этого 
  автоматически создавая или обновляя структуру БД, ориентируясь на Java-классы, который ассоциированы с 
  определенными таблицами. Как было сказано ранее, практически не используется на практике;
- SPI. Service Provider Interface. Внутреннее API, предназначенное для фреймворков, которые разрабатывают 
  собственную имплементацию JPA. По этим же причинам нам оно не интересно - использовать его в типовых задачах не 
  придется. Располагается в пакете `javax.persistence.spi` (`jakarta.persistence.spi`);
- Metamodel API. Предоставляет инструменты для генерации метамоделей - классов с метаинформацией о JPA-сущностях, 
  которые содержат в себе данные о полях этих сущностей, их типах и ряд другой вспомогательной информации. 
  Это достаточно продвинутое направление в JPA и, на мой взгляд, полноценно его изучать начинающим специалистам 
  будет избыточно. Но поскольку большая часть его прикладного применения связана с Criteria API - вместе с Criteria 
  мы тезисно ознакомимся и с метамоделью. Располагается в пакете `javax.persistence.metamodel`
  (`jakarta.persistence.metamodel`).

> Больше информации можно найти в документации -
> [ссылка](https://jakarta.ee/specifications/persistence/3.0/jakarta-persistence-spec-3.0).
> Частично мы познакомимся с ее содержимым в следующих статьях раздела. Что-то же останется за пределами курса.

### Persistence Provider

Как видите, JPA являет собой достаточно объемную спецификацию. При этом в отличие от Servlet API, владения лишь JPA 
может быть недостаточно для эффективной работы за пределами наиболее типовых задач.

Отчасти это связано с тем, что в отличие от Servlet API, реализация JPA выбирается на уровне приложения, а не 
диктуется контейнером сервлетов. И в силу этого на уровне приложения будут доступны классы фреймворка, который 
реализует спецификацию - Persistence Provider'а. Каждый из таких фреймворков имеет свои особенности реализации и 
дополнительные инструменты, которые так или иначе расширяют возможности взаимодействия с базой данных.

В курсе мы познакомимся лишь с наиболее популярным провайдером - фреймворком Hibernate. Но, как и в случае с 
контейнерами сервлетов, самый популярный - не обязательно самый лучший. Как для различных СУБД различные провайдеры 
могут показывать разную эффективность, так и для разных сценариев использования могут быть актуальны дополнительные 
инструменты различных провайдеров. В конечном итоге выбор ORM на каждом отдельно взятом проекте будет зависеть от 
уровня экспертизы лица, принимающего решение, и понимания задач, которые придется решать с помощью ORM.

### JPA и JDBC

Несложно заметить, что JPA решает достаточно серьезные проблемы в работе с БД. И как мы увидим в скором будущем, 
взаимодействие с реляционными БД через JPA и через JDBC кардинально отличается в сторону куда более высокого уровня 
абстракции у JPA. Фактически, вполне реально построить рабочее приложение, ни разу напрямую не обратившись ни к 
нативному SQL, ни к интерфейсам JDBC.

Но также стоит и понимать, что JPA - не что-то принципиально новое. Это лишь надстройка поверх JDBC, со своими 
плюсами и минусами. И какими удобными и красивыми инструментами не оперировал разработчик при работе с JPA, 
фактическая коммуникация с БД будет происходить через JDBC-драйвер и с использованием уже знакомых нам инструментов 
JDBC.

И одним из характеристик хорошего разработчика является то, что он понимает происходящее на каждом из уровней 
абстракции: JPA Provider -> JDBC -> SQL. То же справедливо и для иных высокоуровневых инструментов, которые часто 
являют собой новую надстройку над чем-то известным и более низкоуровневым.

### В заключение о JPA

Подводя итог вводному пункту о JPA, я рекомендую не пытаться объять необъятное и изучить все за раз. JPA - одна из 
тем, к которой придется возвращаться итеративно, по мере появления нового опыта и углубления общей экспертизы в 
Java-разработке. Если новичку будет достаточно понимания основных концепций JPA и знания базового Java API, то в
дальнейшем придется и погрузиться в тонкости спецификации, и разбираться с особенностями реализации в различных 
провайдерах. Но не все сразу.   

## Hibernate

Как уже неоднократно подчеркивалось ранее, изучать JPA мы будем именно на примере Hibernate. Это наиболее популярная 
имплементация с наиболее большим комьюнити. Кроме того, именно Hibernate является провайдером по умолчанию в Spring 
Data JPA - часть экосистемы Spring, с которой мы будем знакомиться далее.

Заранее стоит морально подготовиться к тому, что название одних и тех же вещей в JPA и в Hibernate может отличаться. 
Отчасти это связано с тем, что Hibernate появился как самостоятельная ORM еще до появления JPA. Лишь через несколько 
лет после появления Hibernate (и при его активном участии) была подготовлена общая спецификация, которую на данный 
момент Hibernate и реализует.

В статьях курса будет уделяться внимание различиям в названии, но это все еще может вызывать путаницу среди новичков.
К сожалению, неизбежную.

Также стоит отметить, что Hibernate, как и рассмотренное ранее Servlet API, являются лишь промежуточными разделами. 
Современная разработка чаще использует Hibernate (или иной persistence provider) неявно, внутри еще более 
высокоуровневой настройки - Spring Data JPA.

В силу этого нас будут очень интересовать используемые подходы и механизмы - правила обработки данных в Spring Data 
JPA диктуются именно JPA и провайдером. Но именно изучаемое Java API часто будет нести вспомогательную функцию - 
ощутимая его часть потребуется для демонстрации и будет неактуальна для современных проектов в коммерческой разработке.

## Критика ORM и альтернативы

Несмотря на амбициозные задачи и не самую плохую их реализацию, ORM и, в частности, JPA относительно часто встречает 
критику. Как глобальную в пределах концепции, так и в отношении отдельных механизмов.

Чтобы взвешено оценивать эту критику и формировать собственное мнение, безусловно требуется насмотренность и 
достаточно глубокий уровень знаний.

Тем не менее на данном этапе хочется тезисно обозначить альтернативные подходы к работе с реляционными БД в Java:

- [R2DBC](https://r2dbc.io/). Эта технология представляет собой альтернативу JDBC для работы в реактивном стеке. В 
  данном курсе мы фактически не затрагиваем реактивное программирование, поэтому будет тяжело объяснить ключевую 
  разницу. В первом приближении такой подход можно рассматривать как асинхронный в части любых блокирующих операций. 
  Т.е. если с использованием JDBC любое обращение к БД будет блокировать поток выполнения, то в случае с R2DBC это 
  не так. Реактивный подход не является критикой ORM или JPA в какой-либо мере. Но он плохо совместим с JPA в силу 
  концептуальных различий. При этом Hibernate имеет собственную реализацию на базе R2DBC - Hibernate Reactive. Что 
  позволяет говорить о том, что реактивная ORM существует. Пусть и с некоторыми ограничениями и вне JPA;
- [MyBATIS](https://blog.mybatis.org/). Библиотека, которая в т.ч. предоставляет маппинг для Java-классов с 
  сущностями БД. Но не имплементирует JPA и лишь отчасти могла бы претендовать на реализацию ORM. В чем-то концепция 
  этой библиотеки инвертирует идею ORM о "виртуальной объектной БД"*. Вместо попыток сделать вид, что мы работаем с 
  реляционной БД в парадигме ООП, данная библиотека позволяет эффективно использовать возможности БД, встраивая их в 
  объектно-ориентированную парадигму. Она не так популярна в современной разработке, как могла бы быть. Но сама идея 
  остается интересной и находит своих приверженцев; 
- [JOOQ](https://www.jooq.org/). Еще один инструмент, предлагающий концепции, альтернативные ORM и JPA. Если в JPA 
  мы видели упоминание о генерации DDL на базе Java-классов, то JOOQ многим известен обратным - генерацией 
  Java-сущностей на базе DDL. В действительности его возможности намного шире и подходы по маппингу Java-сущностей в 
  сущности базы данных тоже разнообразны, вплоть до интеграции JOOQ и JPA. Тем не менее эта библиотека в общем 
  случае является самостоятельным инструментом с достаточно большим комьюнити;
- Различные простые обертки над JDBC. Основная их задача - минимизировать boilerplate при работе с БД - ручную 
  работу с `Connection` и другой типовой код, характерный для JDBC, не превнося при этом громоздких абстракций или 
  кардинально новых инструментов. Наиболее известным примером можно, вероятно, считать
  [Spring JDBC](https://docs.spring.io/spring-framework/docs/3.0.x/spring-framework-reference/html/jdbc.html), 
  который предоставляет несколько удобных интерфейсов для работы с запросами и транзакциями, в остальном оставаясь 
  достаточно близким к JDBC API.

> *Виртуальная объектная БД - термин, который был упомянут, но не был разобран в данной статье. Для этого пришлось
> бы углубляться в JPA или иную спецификацию. Поэтому подробнее вернемся к нему в одной из ближайших статей.

Если говорить о критике ORM и JPA, стоит разделять эти два пункта.

Критика ORM во многом базируется на проблемах, которые возникают при попытке подружить реляционный и 
объектно-ориентированный подходы к работе с данными. Тема обширная и разноплановая при желании углубиться рекомендую 
начать с поиска по теме "impedance mismatch" (или object–relational impedance mismatch).

Критика JPA (и, вероятно, других реализаций ORM с небольшими отличиями в аргументации) заключается в сложности самой 
спецификации, которая неминуемо ведет к сложности реализации в конкретных реализациях. И эта же сложность диктует 
ряд специфичных процессов обработки, ограничений и побочных эффектов. Какие-то из них могут подходить под 
определение "не баг, а фича", иные накладывают реальные ограничения в работе, которые либо невозможно обойти, либо 
обходить приходится с костылями на уровне приложения. Это мало относится к простым сценариям взаимодействия, но 
может иметь сильный эффект при необходимости сделать нечто нестандартное.

Как результат, проблемы при работе с JPA могут быть актуальны для специалистов любого уровня квалификации - новички 
могут не знать особенностей и совершать ошибки по незнанию, опытные специалисты вынуждены держать в голове массу 
пограничных ситуаций и сайд-эффектов. И стараться их избегать или, по возможности, использовать во благо. А заодно и 
валидировать решения новичков по тем же параметрам.

Добавляя к этому потенциально меньшую скорость работы JPA в сравнении с JDBC, сообщество критиков JPA и ORM не имеет 
никаких проблем с численностью и аргументацией, почему "так не надо". Проблема лишь в том, что не наблюдается единства 
мнений о том, "как надо".

В заключение остается лишь повторить: собственное мнение каждый составит по мере накопления опыта. И, возможно, 
когда-нибудь мы найдем наиболее оптимальный подход, который устроит всех.

#### На сегодня все!

![img.png](../../../commonmedia/justTheoryFooter.png)

> Если что-то непонятно или не получается – welcome в комменты к посту или в лс:)
>
> Канал: https://t.me/ViamSupervadetVadens
>
> Мой тг: https://t.me/ironicMotherfucker
>
> **Дорогу осилит идущий!**
